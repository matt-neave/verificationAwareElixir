elixir_program = { defmodule | block }

defmodule = { "{:defmodule" ~ ", " ~ metadata ~ ", " ~ "[" ~ alias_name ~ ", " ~ do ~ "]}" }

nil = { "nil" }

// Unused
comma = { ", " }

line_number = { "line: " ~ number }

alias_status = { "alias: " ~ bool }

number = { int | float }

int = { ASCII_DIGIT+ }

float = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

unary_op = { "@" | "." | "+" | "-" | "!" | "^" | "not" | "~~~" }

left_op = { "*" | "/" | "+" | "-" }

right_op = { "++" | "--" | "+++" | "---" | ".." | "<>" | "in" | "not in" | "|>" | "<<<" | ">>>" | "<<~" | "~>>" | "<~" | "~>" | "<~>" | "<|>" | "<" | ">" | "<=" | ">=" | "==" | "!=" | "=~" | "===" | "!==" | "&&" | "&&&" | "and" | "||" | "|||" | "or" | "=" | "|" | "::" | "when" | "<-" | "\\" }

binary_operator = { "+" | "-" | "/" | "*" }

map_op = { "=>" }

operator = { unary_op | left_op | right_op | map_op }

unused_characters = { "{" | "}" | "_" | "\\" }

letters = { ( ASCII_ALPHANUMERIC | operator | unused_characters ) * }

string = { "\"" ~ (ASCII_ALPHANUMERIC | operator | unused_characters | "," | " ")* ~ "\"" }

condensed_list = { "'" ~ letters ~ "'" }

bool = { true | false }

primitive = { bool | int | string | atom | variable }

metadata = { nil | metadata_arguments }

metadata_arguments = { ("[" ~ (metadata_argument ~ ", ")* ~ metadata_argument ~ "]") | "[]" }

metadata_argument = { line_number | alias_status | context }

alias_name = { "{:__aliases__" ~ ", " ~ metadata ~ ", " ~ atoms ~ "}" }

context = { "context: Elixir" }

// TODO: confirm
atoms = { "[" ~ (atom)* ~ "]" }

atom = { ":" ~ letters }

annotation = { ":@" ~ letters }

do_else =  { "[do: " ~ (block_statement | primitive) ~ ", " ~ "else: " ~ (tuple | primitive) ~ "]" }

do_single = { "[do: " ~ (block_statement | primitive) ~ "]" }

do_block = { "[do: " ~ block ~ "]" }

do = { do_block | do_single }

block = { "{:__block__" ~ ", " ~ metadata ~ ", " ~ block_statements ~  "}" }

block_statements = { "[" ~ (block_statement ~ ", ")* ~ block_statement* ~ "]" }

block_statement = { string | assigned_variable | attribute | function_definition | macro | io | directive | assignment | spawn_process | send | receive | defmodule | tuple }

assignment = { "{:=, " ~ metadata ~ ", [" ~ assigned_variable ~ ", " ~ expression_argument ~ "]}" }

assigned_variable = { "{" ~ atom ~ ", " ~ metadata ~ ", nil}"  }

function_definition = { type_spec? ~ ", "? ~ (("{:def" | "{:defp") ~ ", " ~ metadata ~ ", " ~ "[{" ~ function_name ~ ", " ~ metadata ~ ", " ~ function_arguments ~ "}" ~ ", " ~ do ~ "]}") }

type_spec = { "{:@, " ~ metadata ~ ", [{:spec, " ~ metadata ~ ", [{:\"::\", " ~ metadata ~ ", [" ~ function_arguments_type ~ ", " ~ argument_type ~"]}]}]}" } 

function_arguments_type = { "{" ~ atom ~ ", " ~ metadata ~ ", " ~ argument_types ~ "}" }

argument_types = { "[" ~ (argument_type ~ ", ")* ~ argument_type ~ "]" }

integer_type = { ":integer" }

type = { integer_type }

argument_type = { "{" ~ type ~ ", " ~ metadata ~ ", []}" }

function_arguments = { nil | "[]" | ("[" ~ (function_argument ~ ", ")* ~ function_argument ~ "]") }

function_argument = { "{" ~ atom ~ ", " ~ metadata ~ ", " ~ nil ~ "}" }

function_name = { atom }

io = { "{{:., " ~ metadata ~ ", " ~ "[" ~ alias_name ~ ", " ~ ":puts" ~ "]}, " ~ metadata ~ ", [" ~ block_statement ~ "]}" }

if = { "{:if" ~ ", " ~ metadata ~ ", " ~ conditions ~ "}" }

variable = { letters }

or = { "{:or" ~ ", " ~ metadata ~ ", " ~ "[" ~ if_condition ~ ", " ~ if_condition ~ "]" ~ "}" }

and = { "{:and" ~ ", " ~ metadata ~ ", " ~ "[" ~ if_condition ~ ", " ~ if_condition ~ "]" ~ "}" }

// TODO extract (variable | int) to more exhaustive type
variable_argument = { tuple }

operation = { "{:" ~ ANY ~ ", " ~ metadata ~ ", " ~ "[" ~ (variable_argument | primitive) ~ ", " ~ (variable_argument | primitive) ~ "]" ~ "}" }

boolean_expression = { bool | operation }

true = { "true" }

false = { "false" }

not = { "{:not, " ~ metadata ~ ", " ~ "[" ~ if_condition ~ "]}" }

if_condition = { not | or | and | bool | boolean_expression | primitive }

conditions = { "[" ~ if_condition ~ ", " ~ (do | do_else) ~ "]"}

tuple = { function_definition | if | or | and | binary_operation | expression_tuple}

binary_operation = { "{:" ~ binary_operator ~ ", " ~ metadata ~ ", [" ~ tuple ~ ", " ~ tuple ~ "]}" }

expression_tuple = { "{" ~ (io | annotation | atom) ~ ", " ~ metadata ~ ", " ~ expression_arguments ~ "}" } 

expression_arguments = { ("[" ~ (expression_argument ~ ", ")* ~ expression_argument ~ "]") | condensed_list | nil }

// TODO allows for lazy evaluation of negative numbers, doesn't handle subtraction
negative_number = { "{:-, " ~ metadata ~ ", [" ~ number ~ "]}" }

//  --------- MESSAGE PASSING --------- 
send = { "{:send, " ~ metadata ~ ", [" ~ send_target ~ ", " ~ send_arguments ~ "]}" }

send_target = { "{" ~ atom ~ ", " ~ metadata ~ ", nil}" }

send_arguments = { "{:{}, " ~ metadata ~ ", " ~ ( "[]" | "[" ~ (send_argument ~ ", ")* ~ send_argument ~ "]" ) ~ "}" }

send_argument = { atom | number | string | self_pid }

self_pid = { "{:self, " ~ metadata ~ ", []}" }

receive = { "{:receive, " ~ metadata ~ ", [[do: [{:->, " ~ metadata ~ ", [" ~ (single_assignment | multi_assignment) ~ ", "  ~ (block_statement | block) ~ "]}]]]}" }

// Case where receive only assigns to single variable
single_assignment = { "[{" ~ atom ~ ", " ~ metadata ~ ", " ~ nil ~ "}]" }

// Case where receive assings to multiple variables
// TODO can be refactored such that the first element is always an mtype
multi_assignment = { "[{:{}, " ~ metadata ~ ", [" ~ (recv_binding ~ ", ")* ~ recv_binding ~ "]}]" } 
recv_binding = { atom | assigned_variable }

// Lightweight elixir process (not an os process)
// TODO Function arguments may not be appropriate for spawn/
spawn_process = { "{:spawn, " ~ metadata ~ ", [" ~ process_name ~ ", " ~ atom ~ ", " ~ function_arguments ~ "]}" }

// {:__aliases__, [line: 3], [:Calculator]}
process_name = { "{:__aliases__, " ~ metadata ~ ", [" ~ atom ~ "]}" }

expression_argument = { number | negative_number | string | spawn_process | tuple | do }

attribute = { ":@" ~ ", " ~ metadata ~ ", " ~ attributes }

attributes = { "["~ (single_attribute ~ ", ")* ~ single_attribute ~ "]" }

single_attribute = { doc_attribute }

doc_attribute = { "{:doc" ~ ", " ~ metadata ~ ", " ~ "[" ~ string ~ "]}" }

//TODO complete
macro = { "defmacro" }

//TODO complete
directive = { "import" | "alias" | "require" }

//TODO case, match, send, receive, guards, ranges, for comprehensions, maps...