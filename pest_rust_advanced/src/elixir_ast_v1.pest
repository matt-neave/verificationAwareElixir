elixir_program = { defmodule | block }

defmodule = { "{:defmodule" ~ ", " ~ metadata ~ ", " ~ "[" ~ alias_name ~ ", " ~ do ~ "]}" }

nil = { "nil" }

// Unused
comma = { ", " }

line_number = { "line: " ~ number }

alias_status = { "alias: " ~ bool }

number = { int | float }

// TODO check function_argument is strictly appropriate
primitive_array = { 
    "[" ~ (function_argument ~ ", ")* ~ function_argument ~ "]"
}

array = { 
    primitive_array | 
    ("[{:|, " ~ metadata ~ ", [" ~ (function_argument ~ ", ")* ~ function_argument ~ "]}]" ) | 
    ("{:++, " ~ metadata ~  ", [" ~ binary_operand ~ ", " ~ binary_operand ~ "]}" ) | 
    enum_map_call
} 

int = { ASCII_DIGIT+ }

float = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

binary_operator = { "+" | "-" | "/" | "*" }

// TODO: non-exhaustive
boolean_operator = { "==" | "<=" | ">=" | "<" | ">" | "&&" | "||" }

map_op = { "=>" }

operator = { map_op }

unused_characters = { "{" | "}" | "_" | "\\" }

letters = { ( ASCII_ALPHANUMERIC | operator | unused_characters ) * }

alpha_letters = { (ASCII_ALPHANUMERIC | "_") + }

string = { "\"" ~ (ASCII_ALPHANUMERIC | operator | unused_characters | "," | " " | ":")* ~ "\"" }

condensed_list = { "'" ~ letters ~ "'" }

bool = { true | false }

primitive = { bool | number | negative_number | string | atom | primitive_array | self_pid | variable }

metadata = { nil | metadata_arguments }

metadata_arguments = { ("[" ~ (metadata_argument ~ ", ")* ~ metadata_argument ~ "]") | "[]" }

metadata_argument = { line_number | alias_status | context }

alias_name = { "{:__aliases__" ~ ", " ~ metadata ~ ", " ~ atoms ~ "}" }

context = { "context: Elixir" }

// TODO: confirm
atoms = { "[" ~ (atom ~ ", ")* ~ atom? ~ "]" }

atom = { ":" ~ letters }

annotation = { ":@" ~ letters }

do_else =  { "[do: " ~ (block | block_statement | primitive) ~ ", " ~ "else: " ~ (block | block_statement | primitive) ~ "]" }

do_single = { "[do: " ~ (block_statement | primitive) ~ "]" }

do_block = { "[do: " ~ block ~ "]" }

do = { do_block | do_single }

block = { "{:__block__" ~ ", " ~ metadata ~ ", " ~ block_statements ~  "}" }

block_statements = { "[" ~ (block_statement ~ ", ")* ~ block_statement* ~ "]" }

// TODO merge with tuple
block_statement = { string | bool | assigned_variable | attribute | vae_function_definition | function_definition | macro | enum_call | io | for | if | case | pre | directive | array_read | array_assignment  | assignment | statement_assignment | tupled_elements | spawn_process | send | receive | defmodule | tuple }

tuple = { function_definition | unless | or | and | assigned_variable | binary_operation | expression_tuple }

assignment = { "{:=, " ~ metadata ~ ", [" ~ (assigned_variable | tupled_vars) ~ ", " ~ expression_argument ~ "]}" }

statement_assignment = { "{:=, " ~ metadata ~ ", [" ~ (assigned_variable | tupled_vars) ~ ", " ~ block_statement ~ "]}" }

array_assignment = { "{:=, " ~ metadata ~ ", [" ~ assigned_variable ~ ", " ~ array ~ "]}" }

array_read = { "{:=, " ~ metadata ~ ", [" ~ array_assigned_variable ~ ", " ~ expression_argument ~ "]}" }

assigned_variable = { 
    ("{" ~ atom ~ ", " ~ metadata ~ ", nil}")  
}

tupled_vars = {
    "{" ~ (assigned_variable ~ ", ")* ~ assigned_variable ~ "}"
}

tupled_elements = {
    "{" ~ ((assigned_variable | primitive) ~ ", ")* ~ (assigned_variable | primitive) ~ "}"
}

array_assigned_variable = { "[" ~ (assigned_variable ~ ", ")* ~ assigned_variable ~ "]" }

function_definition = { (ltl_spec ~ ", ")? ~ (parameterization ~ ", ")? ~ (vae_init ~ ", ")? ~ (type_spec ~ ", ")? ~ (ltl_spec ~ ", ")? ~ (vae_init ~ ", ")? ~ (parameterization ~ ", ")? ~ (( "{:defp" | "{:def") ~ ", " ~ metadata ~ ", " ~ "[{" ~ function_name ~ ", " ~ metadata ~ ", " ~ function_arguments ~ "}" ~ ", " ~ do ~ "]}") }

vae_function_definition = { (ltl_spec ~ ", ")? ~ (parameterization ~ ", ")? ~ (vae_init ~ ", ")? ~ (type_spec ~ ", ")? ~ (ltl_spec ~ ", ")? ~ (vae_init ~ ", ")? ~ (parameterization ~ ", ")? ~ ( "{:defv, " ~ metadata ~ ", " ~ "[{" ~ function_name ~ ", " ~ metadata ~ ", " ~ function_arguments ~ "}" ~ ", [" ~ pre* ~ ", "* ~ post* ~ ", "* ~ pre*  ~ "], " ~ do ~ "]}") }

pre = { "pre: " ~ boolean_operand }

post = { "post: " ~ boolean_operand }

type_spec = { "{:@, " ~ metadata ~ ", [{:spec, " ~ metadata ~ ", [{:\"::\", " ~ metadata ~ ", [" ~ function_arguments_type ~ ", " ~ argument_type ~"]}]}]}" } 

vae_init = { "{:@, " ~ metadata ~ ", [{:vae_init, " ~ metadata ~ ", [true]}]}" }

ltl_spec = { "{:@, " ~ metadata ~ ", [{:ltl, " ~ metadata ~ ", [\"" ~ ltl ~ "\"]}]}" }

parameterization = { "{:@, " ~ metadata ~ ", [{:param, " ~ metadata ~ (", [{:{}, " ~ metadata ~ ", [" ~ (atom ~ ", ")* ~ atom ~ "]}]}]}" | ", [" ~ alpha_letters ~ ": " ~ atom ~ "]}]}") }

function_arguments_type = { "{" ~ atom ~ ", " ~ metadata ~ ", " ~ argument_types ~ "}" }

argument_types = { ("[" ~ (argument_type ~ ", ")* ~ argument_type ~ "]") | "[]" }

integer_type = { ":integer" }

boolean_type = { ":boolean" }

atom_type = { ":atom" }

type = { integer_type | boolean_type | atom_type }

argument_type = { ("{" ~ type ~ ", " ~ metadata ~ ", []}") | atom }

function_arguments = { nil | "[]" | ("[" ~ (function_argument ~ ", ")* ~ function_argument ~ "]") }

function_argument = { assigned_variable | primitive }

function_name = { atom }

io = { "{{:., " ~ metadata ~ ", " ~ "[" ~ alias_name ~ ", " ~ ":puts" ~ "]}, " ~ metadata ~ ", [" ~ block_statement ~ "]}" }

for = { "{:for, " ~ metadata ~ ", [{:<-, " ~ metadata ~ ", [" ~ assigned_variable ~ ", " ~ (array | assigned_variable) ~ "]}, " ~ do ~ "]}" }

if = { "{:if, " ~ metadata ~ ", " ~ conditions ~ "}" }

unless = { "{:unless" ~ ", " ~ metadata ~ ", " ~ conditions ~ "}" }

case = { "{:case, " ~ metadata ~ ", [" ~ assigned_variable ~ ", [do: " ~ (receive_statements) ~ "]]}" }

variable = { letters }

or = { "{:or" ~ ", " ~ metadata ~ ", " ~ "[" ~ boolean_operand ~ ", " ~ boolean_operand ~ "]" ~ "}" }

and = { "{:and" ~ ", " ~ metadata ~ ", " ~ "[" ~ boolean_operand ~ ", " ~ boolean_operand ~ "]" ~ "}" }

// TODO extract (variable | int) to more exhaustive type
variable_argument = { tuple }

// TODO need variable_argument
boolean_operand = { boolean_operation | not | or | and | assigned_variable | binary_operand | primitive }

boolean_operation = { "{:" ~ boolean_operator ~ ", " ~ metadata ~ ", " ~ "[" ~ boolean_operand ~ ", " ~ boolean_operand ~ "]" ~ "}" }

true = { "true" }

false = { "false" }

not = { "{:not, " ~ metadata ~ ", " ~ "[" ~ boolean_operand ~ "]}" }

conditions = { "[" ~ boolean_operand ~ ", " ~ (do | do_else) ~ "]"}

binary_operand  = { number | string | assigned_variable | binary_operation | primitive_array | expression_tuple }

binary_operation = { "{:" ~ binary_operator ~ ", " ~ metadata ~ ", [" ~ binary_operand ~ ", " ~ binary_operand ~ "]}" }

// TODO Seems expression tuple with atom is always function call, can extract this to function call and refactor 
expression_tuple = { "{" ~ (annotation | atom) ~ ", " ~ metadata ~ ", " ~ expression_arguments ~ "}" } 

expression_arguments = { ("[" ~ (expression_argument ~ ", ")* ~ expression_argument ~ "]") | condensed_list | nil | "[]" }

// TODO allows for lazy evaluation of negative numbers, doesn't handle subtraction
negative_number = { "{:-, " ~ metadata ~ ", [" ~ number ~ "]}" }

//  --------- MESSAGE PASSING --------- 
send = { "{:send, " ~ metadata ~ ", [" ~ send_target ~ ", " ~ (send_atom | send_arguments | send_tupled_arguments) ~ "]}" }

send_atom = { atom }

send_target = { "{" ~ atom ~ ", " ~ metadata ~ (", nil}" | ", []}") }

send_arguments = { "{:{}, " ~ metadata ~ ", " ~ ( "[]" | "[" ~ (send_argument ~ ", ")* ~ send_argument ~ "]" ) ~ "}" }

send_tupled_arguments = { "{" ~ ((atom | number | string | self_pid | binary_operation | assigned_variable | expression_tuple) ~ ", ")* ~ (atom | number | string | self_pid | binary_operation | assigned_variable | expression_tuple) ~ "}" }

send_argument = { atom | number | string | self_pid | binary_operation | assigned_variable | expression_tuple }

// TODO, self_pid is just a special case of a function call!
self_pid = { "{:self, " ~ metadata ~ ", []}" }

receive = { "{:receive, " ~ metadata ~ ", [[do: " ~ (receive_statements) ~ "]]}" }

receive_statements = { "[" ~ (receive_statement ~ ", ")* ~ receive_statement ~ "]" }

receive_statement = { "{:->, " ~ metadata ~ ", [" ~ (receive_atom | receive_primitive | single_assignment | pair_assignment | multi_assignment | receive_multi_atom) ~ ", "  ~ (block | block_statement) ~ "]}"}

// Case where receive is purely an atom to match
receive_atom = { "[" ~ atom ~ "]" }

receive_primitive = { "[" ~ (assigned_variable | primitive) ~ "]" }

receive_multi_atom = { "[" ~ alpha_letters ~ ": " ~ atom ~ "]" }

// Case where receive only assigns to single variable
single_assignment = { "[{" ~ atom ~ ", " ~ metadata ~ ", " ~ nil ~ "}]" }

// Case where receive is a pair, format of [response: {:ans, [line: 6], nil}]
pair_assignment = { "[" ~ alpha_letters ~ ": {" ~ (atom | assigned_variable) ~ ", " ~ metadata ~ ", nil}]" }

// Case where receive assings to multiple variables
// TODO can be refactored such that the first element is always an mtype
multi_assignment = { "[{:{}, " ~ metadata ~ ", [" ~ (recv_binding ~ ", ")* ~ recv_binding ~ "]}]" } 
recv_binding = { atom | assigned_variable }

// Lightweight elixir process (not an os process)
// TODO Function arguments may not be appropriate for spawn/
spawn_process = { "{:spawn, " ~ metadata ~ ", [" ~ process_name ~ ", " ~ atom ~ ", " ~ function_arguments ~ "]}" }

// {:__aliases__, [line: 3], [:Calculator]}
process_name = { "{:__aliases__, " ~ metadata ~ ", [" ~ atom ~ "]}" }

expression_argument = { number | negative_number | bool | self_pid | string | spawn_process | enum_call | array | assigned_variable | binary_operation | anonymous_function | tupled_elements | tuple | do | atom }

attribute = { ":@" ~ ", " ~ metadata ~ ", " ~ attributes }

attributes = { "["~ (single_attribute ~ ", ")* ~ single_attribute ~ "]" }

single_attribute = { doc_attribute }

doc_attribute = { "{:doc" ~ ", " ~ metadata ~ ", " ~ "[" ~ string ~ "]}" }

//TODO complete
macro = { "defmacro" }

// TODO only supports single statements 
anonymous_function = { "{:fn, " ~ metadata ~ ", [{:->, " ~ metadata ~ ", [[" ~ (assigned_variable ~ ", ")* ~ assigned_variable ~ "], " ~ block_statement ~ "]}]}" }

/* Enum Lib */
enum_call = { "{{:., " ~ metadata ~ ", [{:__aliases__, " ~ metadata ~ ", [:Enum]}, " ~ enum_func ~ "]}, " ~ metadata ~ ", [" ~ (expression_argument ~ ", ")* ~ expression_argument* ~ "]}" }
enum_map_call = { "{{:., " ~ metadata ~ ", [{:__aliases__, " ~ metadata ~ ", [:Enum]}, " ~ enum_map ~ "]}, " ~ metadata ~ ", [" ~ (expression_argument ~ ", ")* ~ expression_argument* ~ "]}" }

enum_func = { enum_random | enum_at }

enum_random = { ":random" }

enum_at = { ":at" }

enum_map = { ":map" }

//TODO complete
directive_type = { "import" | "alias" | "require" }

directive_arguments = { "[" ~ (directive_argument ~ ", ")* ~ directive_argument ~ "]" }

directive_argument = {
    "{:__aliases__, " ~ metadata ~ ", [" ~ atom ~ "]}"
}

// {:import, [line: 1], [{:__aliases__, [line: 1], [:Precondition]}]}
directive = { "{:" ~ directive_type ~ ", " ~ metadata ~ ", " ~ directive_arguments ~ "}" }

ltl = { ltl_term ~ (ltl_binop ~ ltl_term)* }

ltl_term = {
    ltl_opd |
    ("(" ~ ltl ~ ")") |
    ltl_unary_term
}

ltl_unary_term = {
    ltl_unop ~ ltl_term
}

ltl_opd = {
    ltl_primitive ~ (ltl_embed_binop ~ ltl_opd)*
}

ltl_primitive = {
    number | alpha_letters
}

ltl_embed_binop = {
    "<=" |">=" | "<" | ">" | "+" | "-" | "=="
}

ltl_unop = {
    always | eventually | ltl_negation
}

always = {
    "always" | "[]"
}

eventually = {
    "eventually" | "<>"
}

ltl_negation = {
    "!"
}

ltl_binop = {
    until | weak_until | dual | ltl_and | ltl_or | implication | equivalence
}

until = {
    "until" | "U"
}

weak_until = {
    "W"
}

dual = {
    "V"
}

ltl_and = {
    "&&" | "/\\"
}

ltl_or = {
    "||" | "\\/"
}

implication = {
    "implies" | "->"
}

equivalence = {
    "equivalent" | "<->"
}


//TODO case, match, send, receive, guards, ranges, for comprehensions, maps...