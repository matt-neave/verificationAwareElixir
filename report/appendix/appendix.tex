\appendix
\chapter{First Appendix}

\subsubsection{First paxos implementation with a bug}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
import VaeLib

defmodule Acceptor do

  @spec start_acceptor() :: :ok
  def start_acceptor do
    acceptedProposal = -1
    acceptedValue = -1
    minProposal = -1
    accept_handler(acceptedProposal, acceptedValue, minProposal)
  end

  @spec accept_handler(integer(), integer(), integer()) :: :ok
  def accept_handler(acceptedProposal, acceptedValue, minProposal) do
    receive do
      {:prepare, n, proposer} ->
        if n > minProposal do
          send proposer, {:promise, acceptedProposal, acceptedValue}
          accept_handler(acceptedProposal, acceptedValue, n)
        else
          send proposer, {:promise, acceptedProposal, acceptedValue}
          accept_handler(acceptedProposal, acceptedValue, minProposal)
        end
      {:accept, n, value, proposer} ->
        if n >= minProposal do
          send proposer, {:accepted, n}
          accept_handler(n, value, n)
        else
          send proposer, {:accepted, minProposal}
          accept_handler(acceptedProposal, acceptedValue, minProposal)
        end
      {:terminate} ->
        IO.puts("Terminating acceptor")
    end
  end
end

defmodule Proposer do
  @spec start_proposer() :: :ok
  def start_proposer do
    receive do
      {:bind, acceptors, proposal_n, value, maj, learner} -> proposer_handler(acceptors, proposal_n, value, maj, learner)
    end
  end

  @spec proposer_handler(list(), integer(), integer(), integer(), integer()) :: :ok
  def proposer_handler(acceptors, proposal_n, value, maj, learner) do
    for acceptor <- acceptors do
      send acceptor, {:prepare, proposal_n, self()}
    end

    receive_prepared(proposal_n, value, maj, 0, 0)
    {prepared_n, prepared_value} = receive do
      {:majority_prepared, n, v} -> {n, v}
    end

    for acceptor <- acceptors do
      send acceptor, {:accept, prepared_n, prepared_value, self()}
    end

    accepted_n = receive_accepted(maj, prepared_n, 0, 0)

    if accepted_n != -1 do
      # Value chosen
      send learner, {:learned, prepared_value}
    else
      # Value was rejected
      send learner, {:learned, 0}
    end
  end

  @spec receive_prepared(integer(), integer(), integer(), integer(), integer()) :: :ok
  def receive_prepared(proposal_n, value, maj, highest_seen_proposal, count) do
    if count >= maj do
      send self(), {:majority_prepared, proposal_n, value}
    else
      receive do
        {:promise, acceptedProposal, acceptedValue} ->
          if acceptedValue != -1 && acceptedProposal > highest_seen_proposal do
            receive_prepared(proposal_n, acceptedValue, maj, acceptedProposal, count + 1)
          else
            receive_prepared(proposal_n, value, maj, highest_seen_proposal, count + 1)
          end
      end
    end
  end

  @spec receive_accepted(integer(), integer(), integer(), integer()) :: integer()
  def receive_accepted(maj, prepared_n, rejections, count) do
    if count >= maj do
      if rejections >= maj do  # BUG IS HERE
        -1
      else
        prepared_n
      end
    else
      receive do
        {:accepted, n} ->
          if n > prepared_n do
            receive_accepted(maj, prepared_n, rejections + 1, count + 1)
          else
            receive_accepted(maj, prepared_n, rejections, count + 1)
          end
      end
    end
  end
end

defmodule Learner do

  @spec start() :: :ok
  @vae_init true
  def start do
    n_acceptors = 3
    quorum = 2
    n_proposers = 2
    vals = [42, 31]
    acceptors = for _ <- 1..n_acceptors do
      spawn(Acceptor, :start_acceptor, [])
    end

    for i <- 1..n_proposers do
      proposer = spawn(Proposer, :start_proposer, [])
      val_i = i - 1
      val = Enum.at(vals, val_i)
      send proposer, {:bind, acceptors, i, val, quorum, self()}
    end
    wait_learned(acceptors, n_proposers, 0)
  end

  @spec wait_learned(list(), integer(), integer()) :: :ok
  @ltl "[]((p->!<>q) && (q->!<>p))"
  @ltl "<>(r)"
  @ltl "[](s)"
  def wait_learned(acceptors, p_n, learned_n) do
    if p_n == learned_n do
      for acceptor <- acceptors do
        send acceptor, {:terminate}
      end
    else
      receive do
        {:learned, final_value} ->
          predicate p, final_value == 31
          predicate q, final_value == 42
          predicate r, final_value != 0
          predicate s, final_value == 0 || final_value == 31 || final_value == 42
          IO.puts("Learned final_value:")
          IO.puts(final_value)
      end
      wait_learned(acceptors, p_n, learned_n + 1)
    end
  end
end

\end{lstlisting}

\subsubsection{First paxos bug message log}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
    Never claim moves to line 6     [(1)]
138:    proc  7 (start_proposer:1) test_out.pml:314 Recv 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 20 (__BIND)
154:    proc  8 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
158:    proc  8 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
162:    proc  8 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
197:    proc  6 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
203:    proc  6 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
205:    proc  9 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
219:    proc  2 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
262:    proc  4 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
278:    proc  0 (:init::1) test_out.pml:521 Send 10,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       -> queue 20 (__BIND)
292:    proc  4 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
300:    proc 11 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
344:    proc  2 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
346:    proc 10 (start_proposer:1) test_out.pml:314 Recv 10,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 20 (__BIND)
370:    proc 14 (receive_prepared:1) test_out.pml:421 Send 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 -> queue 46 (__MAJORITY_PREPARED)
372:    proc  8 (proposer_handler:1) test_out.pml:363 Recv 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 46 (__MAJORITY_PREPARED)
382:    proc  8 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
386:    proc  8 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
390:    proc  8 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
421:    proc 15 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
425:    proc 15 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
429:    proc 15 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
452:    proc 16 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
458:    proc 16 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
460:    proc 12 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
466:    proc 12 (accept_handler:1) test_out.pml:291 Send 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
474:    proc 17 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
492:    proc 17 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
494:    proc 13 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
500:    proc 13 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
512:    proc 18 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 48 (__ACCEPTED)
542:    proc 21 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
554:    proc 20 (receive_prepared:1) test_out.pml:425 Recv 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
560:    proc 23 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
578:    proc 23 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
580:    proc 21 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
582:    proc 24 (receive_prepared:1) test_out.pml:425 Recv 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
602:    proc 25 (receive_prepared:1) test_out.pml:421 Send 10,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 46 (__MAJORITY_PREPARED)
616:    proc 15 (proposer_handler:1) test_out.pml:363 Recv 10,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 46 (__MAJORITY_PREPARED)
626:    proc 15 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
630:    proc 15 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
634:    proc 15 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
659:    proc 27 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 48 (__ACCEPTED)
681:    proc 29 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
699:    proc 29 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
701:    proc 28 (receive_accepted:1) test_out.pml:459 Recv 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 48 (__ACCEPTED)
707:    proc 30 (receive_accepted:1) test_out.pml:454 Send 1    -> queue 78 (ret)
711:    proc 22 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
717:    proc 27 (receive_accepted:1) test_out.pml:466 Recv 1    <- queue 78 (ret1)
719:    proc 27 (receive_accepted:1) test_out.pml:467 Send 1    -> queue 54 (ret)
721:    proc 18 (receive_accepted:1) test_out.pml:471 Recv 1    <- queue 54 (ret2)
723:    proc 18 (receive_accepted:1) test_out.pml:472 Sent 1    -> queue 22 (ret)
724:    proc  8 (proposer_handler:1) test_out.pml:396 Recv 1    <- queue 22 (ret2)
740:    proc 22 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
742:    proc 30 (receive_accepted:1) test_out.pml:459 Recv 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 48 (__ACCEPTED)
748:    proc  8 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 90 (__LEARNED)
762:    proc 31 (receive_accepted:1) test_out.pml:454 Send 2    -> queue 89 (ret)
766:    proc 30 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 89 (ret2)
768:    proc 30 (receive_accepted:1) test_out.pml:472 Send 2    -> queue 81 (ret)
772:    proc 28 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 81 (ret2)
774:    proc 28 (receive_accepted:1) test_out.pml:472 Sent 2    -> queue 41 (ret)
775:    proc 15 (proposer_handler:1) test_out.pml:396 Recv 2    <- queue 41 (ret2)
791:    proc 19 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 90 (__LEARNED)
Never claim moves to line 5     [(!(!((final_value==42))))]
Never claim moves to line 16    [(1)]
807:    proc 26 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
813:    proc 26 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
815:    proc 15 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 90 (__LEARNED)
823:    proc 32 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 90 (__LEARNED)
spin: _spin_nvr.tmp:15, Error: assertion violated
spin: text of failed assertion: assert(!((final_value==31)))
Never claim moves to line 15    [assert(!((final_value==31)))]
spin: trail ends after 826 steps
\end{lstlisting}

\subsubsection{Second paxos implementation with a bug}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
    import VaeLib

    defmodule Acceptor do
    
      @spec start_acceptor() :: :ok
      def start_acceptor do
        acceptedProposal = -1
        acceptedValue = -1
        minProposal = -1
        accept_handler(acceptedProposal, acceptedValue, minProposal)
      end
    
      @spec accept_handler(integer(), integer(), integer()) :: :ok
      def accept_handler(acceptedProposal, acceptedValue, minProposal) do
        receive do
          {:prepare, n, proposer} ->
            if n > minProposal do
              send proposer, {:promise, acceptedProposal, acceptedValue}
              accept_handler(acceptedProposal, acceptedValue, n)
            else
              send proposer, {:promise, acceptedProposal, acceptedValue}
              accept_handler(acceptedProposal, acceptedValue, minProposal)
            end
          {:accept, n, value, proposer} ->
            if n >= minProposal do
              send proposer, {:accepted, n}
              accept_handler(n, value, n)
            else
              send proposer, {:accepted, minProposal}
              accept_handler(acceptedProposal, acceptedValue, minProposal)
            end
          {:terminate} ->
            IO.puts("Terminating acceptor")
        end
      end
    end
    
    defmodule Proposer do
      @spec start_proposer() :: :ok
      def start_proposer do
        receive do
          {:bind, acceptors, proposal_n, value, maj, learner} -> proposer_handler(acceptors, proposal_n, value, maj, learner)
        end
      end
    
      @spec proposer_handler(list(), integer(), integer(), integer(), integer()) :: :ok
      def proposer_handler(acceptors, proposal_n, value, maj, learner) do
        for acceptor <- acceptors do
          send acceptor, {:prepare, proposal_n, self()}
        end
    
        receive_prepared(proposal_n, value, maj, 0, 0)
        {prepared_n, prepared_value} = receive do
          {:majority_prepared, n, v} -> {n, v}
        end
    
        for acceptor <- acceptors do
          send acceptor, {:accept, prepared_n, prepared_value, self()}
        end
    
        accepted_n = receive_accepted(maj, prepared_n, 0, 0)
    
        if accepted_n != -1 do
          # Value chosen
          send learner, {:learned, prepared_value}
        else
          # Value was rejected
          send learner, {:learned, 0}
        end
      end
    
      @spec receive_prepared(integer(), integer(), integer(), integer(), integer()) :: :ok
      def receive_prepared(proposal_n, value, maj, highest_seen_proposal, count) do
        if count >= maj do
          send self(), {:majority_prepared, proposal_n, value}
        else
          receive do
            {:promise, acceptedProposal, acceptedValue} ->
              if acceptedProposal > highest_seen_proposal do
                receive_prepared(acceptedProposal, acceptedValue, maj, acceptedProposal, count + 1) # BUG IS HERE
              else
                receive_prepared(proposal_n, value, maj, highest_seen_proposal, count + 1)
              end
          end
        end
      end
    
      @spec receive_accepted(integer(), integer(), integer(), integer()) :: integer()
      def receive_accepted(maj, prepared_n, rejections, count) do
        if count >= maj do
          if rejections >= 1 do
            -1
          else
            prepared_n
          end
        else
          receive do
            {:accepted, n} ->
              if n > prepared_n do
                receive_accepted(maj, prepared_n, rejections + 1, count + 1)
              else
                receive_accepted(maj, prepared_n, rejections, count + 1)
              end
          end
        end
      end
    end
    
    defmodule Learner do
    
      @spec start() :: :ok
      @vae_init true
      def start do
        n_acceptors = 3
        quorum = 2
        n_proposers = 2
        vals = [42, 31]
        acceptors = for _ <- 1..n_acceptors do
          spawn(Acceptor, :start_acceptor, [])
        end
    
        for i <- 1..n_proposers do
          proposer = spawn(Proposer, :start_proposer, [])
          val_i = i - 1
          val = Enum.at(vals, val_i)
          send proposer, {:bind, acceptors, i, val, quorum, self()}
        end
        wait_learned(acceptors, n_proposers, 0)
      end
    
      @spec wait_learned(list(), integer(), integer()) :: :ok
      @ltl "[]((p->!<>q) && (q->!<>p))"
      @ltl "<>(r)"
      @ltl "[](s)"
      def wait_learned(acceptors, p_n, learned_n) do
        if p_n == learned_n do
          for acceptor <- acceptors do
            send acceptor, {:terminate}
          end
        else
          receive do
            {:learned, final_value} ->
              predicate p, final_value == 31
              predicate q, final_value == 42
              predicate r, final_value != 0
              predicate s, final_value == 0 || final_value == 31 || final_value == 42
              IO.puts("Learned final_value:")
              IO.puts(final_value)
          end
          wait_learned(acceptors, p_n, learned_n + 1)
        end
      end
    end
\end{lstlisting}

\subsubsection{Second paxos bug message log}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
    ltl ltl_1: [] (((! ((final_value==31))) || (! (<> ((final_value==42))))) && ((! ((final_value==42))) || (! (<> ((final_value==31))))))
    ltl ltl_2: <> ((final_value!=0))
    ltl ltl_3: [] ((((final_value==0)) || ((final_value==31))) || ((final_value==42)))
    starting claim 8
    Never claim moves to line 6     [(1)]
    132:    proc  0 (:init::1) test_out.pml:521 Send 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 20 (__BIND)
    138:    proc  7 (start_proposer:1) test_out.pml:314 Recv 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 20 (__BIND)
    154:    proc  8 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    158:    proc  8 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    162:    proc  8 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    197:    proc  6 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    203:    proc  6 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    205:    proc  9 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
    227:    proc  4 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    233:    proc  4 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    235:    proc 10 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
    300:    proc  0 (:init::1) test_out.pml:521 Send 13,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       -> queue 20 (__BIND)
    308:    proc 13 (start_proposer:1) test_out.pml:314 Recv 13,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 20 (__BIND)
    324:    proc 15 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    328:    proc 15 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    332:    proc 15 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    355:    proc 14 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    361:    proc 14 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
    363:    proc 12 (receive_prepared:1) test_out.pml:421 Send 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 -> queue 42 (__MAJORITY_PREPARED)
    365:    proc  8 (proposer_handler:1) test_out.pml:363 Recv 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 42 (__MAJORITY_PREPARED)
    413:    proc  8 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    417:    proc  8 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    421:    proc  8 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    458:    proc 16 (receive_prepared:1) test_out.pml:425 Recv 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
    474:    proc  2 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    486:    proc 11 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    492:    proc 11 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
    510:    proc 18 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    518:    proc 18 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    520:    proc 17 (receive_prepared:1) test_out.pml:425 Recv 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
    542:    proc 19 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 58 (__ACCEPTED)
    548:    proc 20 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    556:    proc 20 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    570:    proc  2 (accept_handler:1) test_out.pml:291 Send 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    586:    proc 24 (receive_prepared:1) test_out.pml:421 Send 13,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 42 (__MAJORITY_PREPARED)
    588:    proc 23 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 58 (__ACCEPTED)
    600:    proc 15 (proposer_handler:1) test_out.pml:363 Recv 13,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 42 (__MAJORITY_PREPARED)
    610:    proc 15 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    614:    proc 15 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    618:    proc 15 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    655:    proc 26 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    661:    proc 27 (receive_accepted:1) test_out.pml:454 Send 1    -> queue 65 (ret)
    665:    proc 23 (receive_accepted:1) test_out.pml:471 Recv 1    <- queue 65 (ret2)
    667:    proc 21 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    673:    proc 26 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    675:    proc 23 (receive_accepted:1) test_out.pml:472 Send 1    -> queue 52 (ret)
    677:    proc 21 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    679:    proc 25 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    687:    proc 25 (accept_handler:1) test_out.pml:278 Send 7,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 26 (__PROMISE)
    699:    proc 27 (receive_accepted:1) test_out.pml:459 Recv 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 58 (__ACCEPTED)
    723:    proc 19 (receive_accepted:1) test_out.pml:466 Recv 1    <- queue 52 (ret1)
    737:    proc 31 (receive_accepted:1) test_out.pml:459 Recv 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 58 (__ACCEPTED)
    755:    proc 30 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    761:    proc 32 (receive_accepted:1) test_out.pml:454 Send 2    -> queue 93 (ret)
    765:    proc 30 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    767:    proc 19 (receive_accepted:1) test_out.pml:467 Sent 1    -> queue 22 (ret)
    768:    proc  8 (proposer_handler:1) test_out.pml:396 Recv 1    <- queue 22 (ret2)
    772:    proc 31 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 93 (ret2)
    780:    proc  8 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 100 (__LEARNED)
    782:    proc 22 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 100 (__LEARNED)
    788:    proc 32 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    794:    proc 32 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    796:    proc 31 (receive_accepted:1) test_out.pml:472 Send 2    -> queue 79 (ret)
    798:    proc 27 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 79 (ret2)
    800:    proc 27 (receive_accepted:1) test_out.pml:472 Sent 2    -> queue 41 (ret)
    801:    proc 15 (proposer_handler:1) test_out.pml:396 Recv 2    <- queue 41 (ret2)
    Never claim moves to line 5     [(!(!((final_value==42))))]
    Never claim moves to line 16    [(1)]
    805:    proc 15 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 100 (__LEARNED)
    817:    proc 33 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 100 (__LEARNED)
    spin: _spin_nvr.tmp:15, Error: assertion violated
    spin: text of failed assertion: assert(!((final_value==31)))
    Never claim moves to line 15    [assert(!((final_value==31)))]
    spin: trail ends after 820 steps
\end{lstlisting}

\subsubsection{Working Consistent Hash Table}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule ConsistentHashRing do
  
    @spec start_ring(list(), integer()) :: :ok
    def start_ring(nodes, n) do
      node_positions = Enum.map(nodes, fn n -> hash(n) end)
      ring_handler(nodes, node_positions, n)
    end
  
    @spec ring_handler(list(), list(), integer()) :: :ok
    defp ring_handler(nodes, node_positions, n) do
      receive do
        {:lookup, key, sender} ->
          position = hash(key)
          node = find_closest_node(nodes, node_positions, position, 0, n)
          send sender, {:ring_pos, node}
          ring_handler(nodes, node_positions, n)
  
        {:add_node, node, sender} ->
          new_nodes = nodes ++ [node]
          new_node_position = hash(node)
          new_node_positions = node_positions ++ [new_node_position]
          send sender, {:node_accepted}
          ring_handler(new_nodes, new_node_positions, n + 1)
  
        {:terminate} ->
          IO.puts("Terminating ring handler")
      end
    end
  
    @spec find_closest_node(list(), list(), integer(), integer(), integer()) :: integer()
    defp find_closest_node(nodes, node_positions, position, i, n) do
      if i >= n do
        Enum.at(nodes, 0)
      else
        check_node = Enum.at(nodes, i)
        check_pos = Enum.at(node_positions, i)
  
        if check_pos >= position do
          check_node
        else
          find_closest_node(nodes, node_positions, position, i + 1, n)
        end
      end
    end
  
    @spec hash(integer()) :: integer()
    defp hash(key) do
      # Example hardcoded hash values for keys and nodes
      case key do
        # Keys
        42 -> 1
        25 -> 8
        31 -> 10
  
        # Nodes
        1 -> 2
        2 -> 5
        3 -> 9
        4 -> 15
      end
    end
  end
  
  defmodule Client do
  
    @vae_init true
    @spec start() :: :ok
    @ltl "[](r1 -> <>(p1))"
    @ltl "[](r2 -> <>(p3))"
    @ltl "[](r3 && n_nodes==3 -> <>(p1))"
    @ltl "[](r3 && n_nodes==4 -> <>(p4))"
    def start do
      n_nodes = 3
      nodes = for i <- 1..n_nodes do
        i
      end
      ring = spawn(ConsistentHashRing, :start_ring, [nodes, n_nodes])
  
      next_key = 42
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 42 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 25
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 25 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      # Dynamically grow the ring
      send ring, {:add_node, 4, self()}
      n_nodes = n_nodes + 1
  
      receive do
        {:node_accepted} ->
          IO.puts("Node 4 added to the ring")
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      predicate p1, ring_position == 1
      predicate p2, ring_position == 2
      predicate p3, ring_position == 3
      predicate p4, ring_position == 4
      predicate r1, next_key == 42
      predicate r2, next_key == 25
      predicate r3, next_key == 31
  
      send ring, {:terminate}
    end
  end  
\end{lstlisting}

\subsubsection{Promela for Consistent Hash Table}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Promela of consistent hash table}, label={lst:dht_promela}]
int n_nodes;
int ring_position;
#define p1 ((ring_position == 1))
#define p2 ((ring_position == 2))
#define p3 ((ring_position == 3))
#define p4 ((ring_position == 4))
int next_key = 42;
#define r1 ((next_key == 42))
#define r2 ((next_key == 25))
#define r3 ((next_key == 31))

proctype __anonymous_0 (int n; chan ret; int __pid) {
chan ret1 = [1] of { int }; /*7*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
run hash(n, ret1, __pid); /*7*/
int __ret_placeholder_1; /*7*/
ret1 ? __ret_placeholder_1; /*7*/
ret ! __ret_placeholder_1; /*7*/
}

proctype start_ring (int nodes;int n; chan ret; int __pid) {
chan __anonymous_ret_0 = [0] of { int };
chan ret2 = [1] of { int }; /*8*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
int node_positions;
__get_next_memory_allocation(node_positions);
atomic {
int __iter;
__iter = 0;
do
:: __iter >= LIST_LIMIT -> break;
:: else ->
if
:: LIST_ALLOCATED(nodes, __iter) ->
run __anonymous_0(LIST_VAL(nodes, __iter),__anonymous_ret_0,__pid);
LIST_ALLOCATED(node_positions, __iter) = true;
__anonymous_ret_0 ? LIST_VAL(node_positions, __iter);
__iter++;
:: else -> __iter++;
fi
od
}
int __temp_cp_arr_0;
__copy_memory_to_next(__temp_cp_arr_0, nodes);
int __temp_cp_arr_1;
__copy_memory_to_next(__temp_cp_arr_1, node_positions);
run ring_handler(__temp_cp_arr_0,__temp_cp_arr_1,n, ret2, __pid); /*8*/
}

proctype ring_handler (int nodes;int node_positions;int n; chan ret; int __pid) {
chan ret1 = [0] of { int }; /*15*/
chan ret2 = [0] of { int }; /*16*/
chan ret3 = [1] of { int }; /*18*/
chan ret4 = [0] of { int }; /*22*/
chan ret5 = [1] of { int }; /*25*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
MessageList rec_v_0; /*13*/
do /*13*/
:: __LOOKUP ?? eval(__pid),LOOKUP, rec_v_0 -> /*14*/
int key; /*14*/
key = rec_v_0.m1.data2; /*14*/
int sender; /*14*/
sender = rec_v_0.m2.data2; /*14*/
int position;
position = run hash(key, ret1, __pid); /*15*/
ret1 ? position; /*15*/
int node;
int __temp_cp_arr_2;
__copy_memory_to_next(__temp_cp_arr_2, nodes);
int __temp_cp_arr_3;
__copy_memory_to_next(__temp_cp_arr_3, node_positions);
node = run find_closest_node(__temp_cp_arr_2,__temp_cp_arr_3,position,0,n, ret2, __pid); /*16*/
ret2 ? node; /*16*/
MessageList msg_0; /*17*/
msg_0.m1.data2 = node; /*17*/
__RING_POS !! sender,RING_POS, msg_0; /*17*/
int __temp_cp_arr_4;
__copy_memory_to_next(__temp_cp_arr_4, nodes);
int __temp_cp_arr_5;
__copy_memory_to_next(__temp_cp_arr_5, node_positions);
run ring_handler(__temp_cp_arr_4,__temp_cp_arr_5,n, ret3, __pid); /*18*/
break;
:: __ADD_NODE ?? eval(__pid),ADD_NODE, rec_v_0 -> /*20*/
node = rec_v_0.m1.data2; /*20*/
sender = rec_v_0.m2.data2; /*20*/
int new_nodes;
__get_next_memory_allocation(new_nodes);
__list_append_list(new_nodes, nodes);
__list_append(new_nodes, node);
int new_node_position;
new_node_position = run hash(node, ret4, __pid); /*22*/
ret4 ? new_node_position; /*22*/
int new_node_positions;
__get_next_memory_allocation(new_node_positions);
__list_append_list(new_node_positions, node_positions);
__list_append(new_node_positions, new_node_position);
MessageList msg_1; /*24*/
__NODE_ACCEPTED !! sender,NODE_ACCEPTED, msg_1; /*24*/
int __temp_cp_arr_6;
__copy_memory_to_next(__temp_cp_arr_6, new_nodes);
int __temp_cp_arr_7;
__copy_memory_to_next(__temp_cp_arr_7, new_node_positions);
run ring_handler(__temp_cp_arr_6,__temp_cp_arr_7,n + 1, ret5, __pid); /*25*/
break;
:: __TERMINATE ?? eval(__pid),TERMINATE, rec_v_0 -> /*27*/
printf("Terminating ring handler\n");
break;
od;
}

proctype find_closest_node (int nodes;int node_positions;int position;int i;int n; chan ret; int __pid) {
chan ret1 = [1] of { int }; /*43*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
if
:: (i >= n) -> /*0*/
ret ! __list_at(nodes, 0)
:: else ->
int check_node;
check_node = __list_at(nodes, i)
int check_pos;
check_pos = __list_at(node_positions, i)
if
:: (check_pos >= position) -> /*0*/
ret ! check_node; /*41*/
:: else ->
int __temp_cp_arr_8;
__copy_memory_to_next(__temp_cp_arr_8, nodes);
int __temp_cp_arr_9;
__copy_memory_to_next(__temp_cp_arr_9, node_positions);
run find_closest_node(__temp_cp_arr_8,__temp_cp_arr_9,position,i + 1,n, ret1, __pid); /*43*/
int __ret_placeholder_1; /*43*/
ret1 ? __ret_placeholder_1; /*43*/
ret ! __ret_placeholder_1; /*43*/
fi;
fi;
}

proctype hash (int key; chan ret; int __pid) {
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
do
:: key == 42 ->
ret ! 1; /*0*/
break;
:: key == 25 ->
ret ! 8; /*0*/
break;
:: key == 31 ->
ret ! 10; /*0*/
break;
:: key == 1 ->
ret ! 2; /*0*/
break;
:: key == 2 ->
ret ! 5; /*0*/
break;
:: key == 3 ->
ret ! 9; /*0*/
break;
:: key == 4 ->
ret ! 15; /*0*/
break;
od
}

active proctype start () {
chan ret1 = [1] of { int };
int __pid = 0;
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
n_nodes = 3;
int nodes;
__get_next_memory_allocation(nodes);
int i;
for(i : 1 .. n_nodes) { /*76*/
int __tmp;
__tmp = i; /*77*/
__list_append(nodes, __tmp);
}
int ring;
atomic {
ring = run start_ring(nodes,n_nodes,ret1,-1); /*79*/
}
MessageList msg_0; /*82*/
msg_0.m1.data2 = next_key; /*82*/
msg_0.m2.data2 = __pid; /*82*/
__LOOKUP !! ring,LOOKUP, msg_0; /*82*/
MessageList rec_v_1; /*83*/
do /*83*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_1 -> /*0*/
int node; /*0*/
node = rec_v_1.m1.data2; /*0*/
printf("Key 42 is assigned to\n");
printf("node\n");
ring_position = node; /*87*/
break;
od;
next_key = 25;
MessageList msg_1; /*91*/
msg_1.m1.data2 = next_key; /*91*/
msg_1.m2.data2 = __pid; /*91*/
__LOOKUP !! ring,LOOKUP, msg_1; /*91*/
MessageList rec_v_2; /*92*/
do /*92*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_2 -> /*0*/
node = rec_v_2.m1.data2; /*0*/
printf("Key 25 is assigned to\n");
printf("node\n");
ring_position = node; /*96*/
break;
od;
next_key = 31;
MessageList msg_2; /*100*/
msg_2.m1.data2 = next_key; /*100*/
msg_2.m2.data2 = __pid; /*100*/
__LOOKUP !! ring,LOOKUP, msg_2; /*100*/
MessageList rec_v_3; /*101*/
do /*101*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_3 -> /*0*/
node = rec_v_3.m1.data2; /*0*/
printf("Key 31 is assigned to\n");
printf("node\n");
ring_position = node; /*105*/
break;
od;
MessageList msg_3; /*109*/
msg_3.m1.data2 = 4; /*109*/
msg_3.m2.data2 = __pid; /*109*/
__ADD_NODE !! ring,ADD_NODE, msg_3; /*109*/
n_nodes = n_nodes + 1; 
MessageList rec_v_4; /*112*/
do /*112*/
:: __NODE_ACCEPTED ?? eval(__pid),NODE_ACCEPTED, rec_v_4 -> /*113*/
printf("Node 4 added to the ring\n");
break;
od;
next_key = 31;
MessageList msg_4; /*118*/
msg_4.m1.data2 = next_key; /*118*/
msg_4.m2.data2 = __pid; /*118*/
__LOOKUP !! ring,LOOKUP, msg_4; /*118*/
MessageList rec_v_5; /*119*/
do /*119*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_5 -> /*0*/
node = rec_v_5.m1.data2; /*0*/
printf("Key 31 is assigned to\n");
printf("node\n");
ring_position = node; /*123*/
break;
od;
MessageList msg_5; /*134*/
__TERMINATE !! ring,TERMINATE, msg_5; /*134*/
}


ltl ltl_1 { [](r1 -> <>(p1)) };
ltl ltl_2 { [](r2 -> <>(p3)) };
ltl ltl_3 { [](r3 && n_nodes==3 -> <>(p1)) };
ltl ltl_4 { [](r3 && n_nodes==4 -> <>(p4)) };

\end{lstlisting}

\subsubsection{Buggy Consistent Hash Table}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule ConsistentHashRingB do
  
    @spec start_ring(list(), integer()) :: :ok
    def start_ring(nodes, n) do
      node_positions = Enum.map(nodes, fn n -> hash(n) end)
      ring_handler(nodes, node_positions, n)
    end
  
    @spec ring_handler(list(), list(), integer()) :: :ok
    defp ring_handler(nodes, node_positions, n) do
      receive do
        {:lookup, key, sender} ->
          position = hash(key)
          node = find_closest_node(nodes, node_positions, position, 0, n)
          send sender, {:ring_pos, node}
          ring_handler(nodes, node_positions, n)
  
        {:add_node, node} ->
          new_nodes = nodes ++ [node]
          new_node_position = hash(node)
          new_node_positions = node_positions ++ [new_node_position]
          ring_handler(new_nodes, new_node_positions, n + 1)
  
        {:terminate} ->
          IO.puts("Terminating ring handler")
      end
    end
  
    @spec find_closest_node(list(), list(), integer(), integer(), integer()) :: integer()
    defp find_closest_node(nodes, node_positions, position, i, n) do
      if i >= n do
        Enum.at(nodes, 0)
      else
        check_node = Enum.at(nodes, i)
        check_pos = Enum.at(node_positions, i)
  
        if check_pos >= position do
          check_node
        else
          find_closest_node(nodes, node_positions, position, i + 1, n)
        end
      end
    end
  
    @spec hash(integer()) :: integer()
    defp hash(key) do
      # Example hardcoded hash values for keys and nodes
      case key do
        # Keys
        42 -> 1
        25 -> 8
        31 -> 10
  
        # Nodes
        1 -> 2
        2 -> 5
        3 -> 9
        4 -> 15
      end
    end
  end
  
  defmodule ClientB do
  
    @vae_init true
    @spec start() :: :ok
    @ltl "[](r1 -> <>(p1))"
    @ltl "[](r2 -> <>(p3))"
    @ltl "[](r3 && n_nodes==3 -> <>(p1))"
    @ltl "[](r3 && n_nodes==4 -> <>(p4))"
    def start do
      n_nodes = 3
      nodes = for i <- 1..n_nodes do
        i
      end
      ring = spawn(ConsistentHashRingB, :start_ring, [nodes, n_nodes])
  
      next_key = 42
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 42 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 25
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 25 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      # Dynamically grow the ring
      send ring, {:add_node, 4}
      n_nodes = n_nodes + 1
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      predicate p1, ring_position == 1
      predicate p2, ring_position == 2
      predicate p3, ring_position == 3
      predicate p4, ring_position == 4
      predicate r1, next_key == 42
      predicate r2, next_key == 25
      predicate r3, next_key == 31
  
      send ring, {:terminate}
    end
  end
  
\end{lstlisting}
  
\subsubsection{Buggy Hash Table Logs}

\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
The program is livelocked, or an ltl property was violated. Generating trace.
<<<Message Events>>>
[1] (hash:1) send [2]
[2] (__anonymous_0:1) recv [2]
[3] (start_ring:1) recv [2]
[4] (hash:1) send [5]
[5] (__anonymous_0:1) recv [5]
[6] (start_ring:1) recv [5]
[7] (hash:1) send [9]
[8] (__anonymous_0:1) recv [9]
[9] (start_ring:1) recv [9]
[10] (start:1) send [1,LOOKUP,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[11] (ring_handler:1) recv [1,LOOKUP,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[12] (ring_handler:1) recv [1]
[13] (ring_handler:1) recv [1]
[14] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[15] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[16] (start:1) send [1,LOOKUP,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[17] (ring_handler:1) recv [1,LOOKUP,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[18] (ring_handler:1) recv [8]
[19] (find_closest_node:1) send [3]
[20] (find_closest_node:1) recv [3]
[21] (find_closest_node:1) send [3]
[22] (find_closest_node:1) recv [3]
[23] (ring_handler:1) recv [3]
[24] (ring_handler:1) send [0,RING_POS,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[25] (start:1) recv [0,RING_POS,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[26] (start:1) send [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[27] (ring_handler:1) recv [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[28] (ring_handler:1) recv [10]
[29] (find_closest_node:1) send [1]
[30] (find_closest_node:1) recv [1]
[31] (find_closest_node:1) send [1]
[32] (find_closest_node:1) recv [1]
[33] (find_closest_node:1) send [1]
[34] (find_closest_node:1) recv [1]
[35] (ring_handler:1) recv [1]
[36] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[37] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[38] (start:1) send [1,ADD_NODE,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[39] (start:1) send [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[40] (ring_handler:1) recv [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[41] (ring_handler:1) recv [10]
[42] (find_closest_node:1) send [1]
[43] (find_closest_node:1) recv [1]
[44] (find_closest_node:1) send [1]
[45] (find_closest_node:1) recv [1]
[46] (find_closest_node:1) send [1]
[47] (find_closest_node:1) recv [1]
[48] (ring_handler:1) recv [1]
[49] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[50] (ring_handler:1) recv [1,ADD_NODE,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[51] (ring_handler:1) recv [15]
[52] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[53] (start:1) send [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[54] (ring_handler:1) recv [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{lstlisting}

\subsubsection{LTLixir 2PC}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule Coordinator do
    @spec start_coordinator(list(), integer(), integer(), integer()) :: :ok
    def start_coordinator(participants, transaction_id, value, n_participants) do
      coordinator_handler(participants, transaction_id, value, 0, n_participants)
    end
  
    @spec coordinator_handler(list(), integer(), integer(), integer(), integer()) :: :ok
    defp coordinator_handler(participants, transaction_id, value, phase, n_participants) do
      case phase do
        0 -> # Phase 1: Prepare
          for participant <- participants do
            send participant, {:prepare, transaction_id, value, self()}
          end
          receive_prepare_responses(participants, transaction_id, value, 0, 0, n_participants)
        1 -> # Phase 2: Commit
          for participant <- participants do
            send participant, {:commit, transaction_id, self()}
          end
          wait_for_acks(participants, 0, n_participants, 1)
      end
    end
  
    @spec receive_prepare_responses(list(), integer(), integer(), integer(), integer(), integer()) :: :ok
    defp receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants) do
      if count >= n_participants do
        if acks == n_participants do
          coordinator_handler(participants, transaction_id, value, 1, n_participants)
        else
          IO.puts("Transaction aborted")
          for participant <- participants do
            send participant, {:abort, transaction_id, self()}
          end
          wait_for_acks(participants, 0, n_participants, 0)
        end
      else
        receive do
          {:prepared, response_transaction_id, participant} ->
            if response_transaction_id == transaction_id do
              receive_prepare_responses(participants, transaction_id, value, count + 1, acks + 1, n_participants)
            else
              receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants)
            end
          {:abort, response_transaction_id, participant} ->
            if response_transaction_id == transaction_id do
              receive_prepare_responses(participants, transaction_id, value, count + 1, acks, n_participants)
            else
              receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants)
            end
        end
      end
    end
  
    @spec wait_for_acks(list(), integer(), integer(), integer()) :: :ok
    defp wait_for_acks(participants, count, n_participants, committed) do
      if count >= n_participants do
        if committed == 1 do
          IO.puts("Transaction committed")
        end
        for participant <- participants do
          send participant, {:terminate}
        end
      else
        receive do
          {:ack, _participant} ->
            wait_for_acks(participants, count + 1, n_participants, committed)
        end
      end
    end
  end
  
  defmodule Participant do
    @spec start_participant(integer()) :: :ok
    def start_participant(client) do
      participant_handler(client)
    end
  
    @spec participant_handler(integer()) :: :ok
    defp participant_handler(client) do
      receive do
        {:prepare, transaction_id, value, coordinator} ->
          prepare = decide_to_prepare(value)
          if prepare do
            send coordinator, {:prepared, transaction_id, self()}
          else
            send coordinator, {:abort, transaction_id, self()}
          end
          participant_handler(client)
        {:commit, transaction_id, coordinator} ->
          commit(transaction_id, client)
          send coordinator, {:ack, self()}
          participant_handler(client)
        {:abort, transaction_id, coordinator} ->
          abort(transaction_id, client)
          send coordinator, {:ack, self()}
          participant_handler(client)
        {:terminate} ->
          IO.puts("Terminating participant")
      end
    end
  
    @spec decide_to_prepare(integer()) :: boolean()
    defp decide_to_prepare(value) do
      # Example decision logic i.e. ensure all locks are required to make the commit
      # We use some arbitrary random logic
      cmps = [10, 90]
      cmp = Enum.random(cmps)
      if value < cmp do
        true
      else
        false
      end
    end
  
    @spec commit(integer(), integer()) :: :ok
    defp commit(transaction_id, client) do
      IO.puts("Committing transaction")
      send client, {:transaction_commit}
    end
  
    @spec abort(integer(), integer()) :: :ok
    defp abort(transaction_id, client) do
      IO.puts("Aborting transaction")
      send client, {:transaction_abort}
  
    end
  end
  
  defmodule Client do
    @vae_init true
    @spec start() :: :ok
    def start do
      n_participants = 3
      participants = for _ <- 1..n_participants do
        spawn(Participant, :start_participant, [self()])
      end
  
      transaction_id = 1
      value = 42
      coordinator = spawn(Coordinator, :start_coordinator, [participants, transaction_id, value, n_participants])
  
      await_transaction_result(0, 0, n_participants)
    end
  
    @spec await_transaction_result(integer(), integer(), integer()) :: :ok
    @ltl "<>[]p || <>[]q"
    @ltl "[](p -> !<>[]q)"
    @ltl "[](q -> !<>[]p)"
    def await_transaction_result(n_c, n_a, n_p) do
      commit_count = n_c
      abort_count = n_a
      participant_count = n_p
      predicate p, commit_count == participant_count
      predicate q, abort_count == participant_count
      if n_c + n_a >= n_p do
        IO.puts("All participants have responded")
      else
        receive do
          {:transaction_commit} ->
            await_transaction_result(n_c + 1, n_a, n_p)
          {:transaction_abort} ->
            await_transaction_result(n_c, n_a + 1, n_p)
        end
      end
    end
  end
  
\end{lstlisting}

\subsubsection{Buggy 2PC Logs}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
The program is livelocked, or an ltl property was violated. Generating trace.
<<<Message Events>>>
[1] (coordinator_handler:1) send [1,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[2] (coordinator_handler:1) send [3,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[3] (coordinator_handler:1) send [5,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[4] (participant_handler:1) recv [5,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[5] (participant_handler:1) recv [1]
[6] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[7] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[8] (participant_handler:1) recv [3,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[9] (participant_handler:1) recv [1]
[10] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[11] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[12] (participant_handler:1) recv [1,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[13] (participant_handler:1) recv [1]
[14] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[15] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[16] (coordinator_handler:1) send [1,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[17] (coordinator_handler:1) send [3,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[18] (coordinator_handler:1) send [5,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[19] (participant_handler:1) recv [3,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[20] (commit:1) send [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[21] (participant_handler:1) send [7,ACK,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[22] (wait_for_acks:1) recv [7,ACK,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[23] (participant_handler:1) recv [5,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[24] (commit:1) send [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[25] (participant_handler:1) send [7,ACK,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[26] (wait_for_acks:1) recv [7,ACK,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[27] (participant_handler:1) recv [1,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[28] (commit:1) send [0,TRANSACTION_ABORT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[29] (participant_handler:1) send [7,ACK,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[30] (wait_for_acks:1) recv [7,ACK,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[31] (wait_for_acks:1) send [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[32] (wait_for_acks:1) send [3,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[33] (wait_for_acks:1) send [5,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[34] (participant_handler:1) recv [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[35] (participant_handler:1) recv [5,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[36] (participant_handler:1) recv [3,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[37] (await_transaction_result:1) recv [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[38] (await_transaction_result:1) recv [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[39] (await_transaction_result:1) recv [0,TRANSACTION_ABORT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{lstlisting}
