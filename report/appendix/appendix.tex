\appendix
\chapter{First Appendix}
\section{Verlixir Example}

\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule Server do
    @vae_init true
    @ltl "(q)U([]p)"
    @spec start_server() :: :ok
    @params {:number_of_rounds}
    def start_server do
      predicate p, alive_clients == client_n * number_of_rounds
      predicate q, !p
      client_n = 1
      number_of_rounds = 2
      alive_clients = 0
      for _ <- 1..client_n do
        client = spawn(Client, :start_client, [])
        send(client, {:bind, self(), number_of_rounds})
      end
      alive_clients = if number_of_rounds > 1 do
        check_clients(client_n * number_of_rounds, alive_clients)
      else
        0
      end
    end
  
    @spec check_clients(integer(), integer()) :: integer()
    def check_clients(expected_clients, current_clients) do
      if expected_clients == current_clients do
        current_clients
      else
        receive do
          {:im_alive} -> check_clients(expected_clients, current_clients + 1)
        end
      end
    end
  end
  
  defmodule Client do
    @spec start_client() :: :ok
    def start_client do
      {server, rounds} = receive do
        {:bind, sender, round_limit} -> {sender, round_limit}
      end
      next_round(server, rounds)
    end
  
    @spec next_round(pid(), integer()) :: :ok
    defv next_round(server, rounds), pre: rounds >= 0 do
      if rounds == 0 do
        :ok
      else
        send(server, {:im_alive})
        next_round(server, rounds - 1)
      end
    end
  end
  
\end{lstlisting}

\section{Paxos}
\subsubsection{First paxos implementation with a bug}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
import VaeLib

defmodule Acceptor do

  @spec start_acceptor() :: :ok
  def start_acceptor do
    acceptedProposal = -1
    acceptedValue = -1
    minProposal = -1
    accept_handler(acceptedProposal, acceptedValue, minProposal)
  end

  @spec accept_handler(integer(), integer(), integer()) :: :ok
  def accept_handler(acceptedProposal, acceptedValue, minProposal) do
    receive do
      {:prepare, n, proposer} ->
        if n > minProposal do
          send proposer, {:promise, acceptedProposal, acceptedValue}
          accept_handler(acceptedProposal, acceptedValue, n)
        else
          send proposer, {:promise, acceptedProposal, acceptedValue}
          accept_handler(acceptedProposal, acceptedValue, minProposal)
        end
      {:accept, n, value, proposer} ->
        if n >= minProposal do
          send proposer, {:accepted, n}
          accept_handler(n, value, n)
        else
          send proposer, {:accepted, minProposal}
          accept_handler(acceptedProposal, acceptedValue, minProposal)
        end
      {:terminate} ->
        IO.puts("Terminating acceptor")
    end
  end
end

defmodule Proposer do
  @spec start_proposer() :: :ok
  def start_proposer do
    receive do
      {:bind, acceptors, proposal_n, value, maj, learner} -> proposer_handler(acceptors, proposal_n, value, maj, learner)
    end
  end

  @spec proposer_handler(list(), integer(), integer(), integer(), integer()) :: :ok
  def proposer_handler(acceptors, proposal_n, value, maj, learner) do
    for acceptor <- acceptors do
      send acceptor, {:prepare, proposal_n, self()}
    end

    receive_prepared(proposal_n, value, maj, 0, 0)
    {prepared_n, prepared_value} = receive do
      {:majority_prepared, n, v} -> {n, v}
    end

    for acceptor <- acceptors do
      send acceptor, {:accept, prepared_n, prepared_value, self()}
    end

    accepted_n = receive_accepted(maj, prepared_n, 0, 0)

    if accepted_n != -1 do
      # Value chosen
      send learner, {:learned, prepared_value}
    else
      # Value was rejected
      send learner, {:learned, 0}
    end
  end

  @spec receive_prepared(integer(), integer(), integer(), integer(), integer()) :: :ok
  def receive_prepared(proposal_n, value, maj, highest_seen_proposal, count) do
    if count >= maj do
      send self(), {:majority_prepared, proposal_n, value}
    else
      receive do
        {:promise, acceptedProposal, acceptedValue} ->
          if acceptedValue != -1 && acceptedProposal > highest_seen_proposal do
            receive_prepared(proposal_n, acceptedValue, maj, acceptedProposal, count + 1)
          else
            receive_prepared(proposal_n, value, maj, highest_seen_proposal, count + 1)
          end
      end
    end
  end

  @spec receive_accepted(integer(), integer(), integer(), integer()) :: integer()
  def receive_accepted(maj, prepared_n, rejections, count) do
    if count >= maj do
      if rejections >= maj do  # BUG IS HERE
        -1
      else
        prepared_n
      end
    else
      receive do
        {:accepted, n} ->
          if n > prepared_n do
            receive_accepted(maj, prepared_n, rejections + 1, count + 1)
          else
            receive_accepted(maj, prepared_n, rejections, count + 1)
          end
      end
    end
  end
end

defmodule Learner do

  @spec start() :: :ok
  @vae_init true
  def start do
    n_acceptors = 3
    quorum = 2
    n_proposers = 2
    vals = [42, 31]
    acceptors = for _ <- 1..n_acceptors do
      spawn(Acceptor, :start_acceptor, [])
    end

    for i <- 1..n_proposers do
      proposer = spawn(Proposer, :start_proposer, [])
      val_i = i - 1
      val = Enum.at(vals, val_i)
      send proposer, {:bind, acceptors, i, val, quorum, self()}
    end
    wait_learned(acceptors, n_proposers, 0)
  end

  @spec wait_learned(list(), integer(), integer()) :: :ok
  @ltl """
  []((p->!<>q) && (q->!<>p))
  <>(r)
  [](s)
  """
  def wait_learned(acceptors, p_n, learned_n) do
    predicate p, final_value == 31
    predicate q, final_value == 42
    predicate r, final_value != 0
    predicate s, final_value == 0 || final_value == 31 || final_value == 42

    if p_n == learned_n do
      for acceptor <- acceptors do
        send acceptor, {:terminate}
      end
    else
      receive do
        {:learned, final_value} ->
          IO.puts("Learned final_value:")
          IO.puts(final_value)
      end
      wait_learned(acceptors, p_n, learned_n + 1)
    end
  end
end

\end{lstlisting}

\subsubsection{First paxos bug message log}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
    Never claim moves to line 6     [(1)]
138:    proc  7 (start_proposer:1) test_out.pml:314 Recv 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 20 (__BIND)
154:    proc  8 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
158:    proc  8 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
162:    proc  8 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
197:    proc  6 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
203:    proc  6 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
205:    proc  9 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
219:    proc  2 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
262:    proc  4 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
278:    proc  0 (:init::1) test_out.pml:521 Send 10,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       -> queue 20 (__BIND)
292:    proc  4 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
300:    proc 11 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
344:    proc  2 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
346:    proc 10 (start_proposer:1) test_out.pml:314 Recv 10,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 20 (__BIND)
370:    proc 14 (receive_prepared:1) test_out.pml:421 Send 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 -> queue 46 (__MAJORITY_PREPARED)
372:    proc  8 (proposer_handler:1) test_out.pml:363 Recv 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 46 (__MAJORITY_PREPARED)
382:    proc  8 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
386:    proc  8 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
390:    proc  8 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 47 (__ACCEPT)
421:    proc 15 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
425:    proc 15 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
429:    proc 15 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
452:    proc 16 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
458:    proc 16 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
460:    proc 12 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
466:    proc 12 (accept_handler:1) test_out.pml:291 Send 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
474:    proc 17 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
492:    proc 17 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
494:    proc 13 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
500:    proc 13 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
512:    proc 18 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 48 (__ACCEPTED)
542:    proc 21 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,2,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
554:    proc 20 (receive_prepared:1) test_out.pml:425 Recv 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
560:    proc 23 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 47 (__ACCEPT)
578:    proc 23 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 48 (__ACCEPTED)
580:    proc 21 (accept_handler:1) test_out.pml:272 Send 10,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
582:    proc 24 (receive_prepared:1) test_out.pml:425 Recv 10,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
602:    proc 25 (receive_prepared:1) test_out.pml:421 Send 10,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 46 (__MAJORITY_PREPARED)
616:    proc 15 (proposer_handler:1) test_out.pml:363 Recv 10,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 46 (__MAJORITY_PREPARED)
626:    proc 15 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
630:    proc 15 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
634:    proc 15 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 47 (__ACCEPT)
659:    proc 27 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 48 (__ACCEPTED)
681:    proc 29 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
699:    proc 29 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
701:    proc 28 (receive_accepted:1) test_out.pml:459 Recv 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 48 (__ACCEPTED)
707:    proc 30 (receive_accepted:1) test_out.pml:454 Send 1    -> queue 78 (ret)
711:    proc 22 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
717:    proc 27 (receive_accepted:1) test_out.pml:466 Recv 1    <- queue 78 (ret1)
719:    proc 27 (receive_accepted:1) test_out.pml:467 Send 1    -> queue 54 (ret)
721:    proc 18 (receive_accepted:1) test_out.pml:471 Recv 1    <- queue 54 (ret2)
723:    proc 18 (receive_accepted:1) test_out.pml:472 Sent 1    -> queue 22 (ret)
724:    proc  8 (proposer_handler:1) test_out.pml:396 Recv 1    <- queue 22 (ret2)
740:    proc 22 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
742:    proc 30 (receive_accepted:1) test_out.pml:459 Recv 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 48 (__ACCEPTED)
748:    proc  8 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 90 (__LEARNED)
762:    proc 31 (receive_accepted:1) test_out.pml:454 Send 2    -> queue 89 (ret)
766:    proc 30 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 89 (ret2)
768:    proc 30 (receive_accepted:1) test_out.pml:472 Send 2    -> queue 81 (ret)
772:    proc 28 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 81 (ret2)
774:    proc 28 (receive_accepted:1) test_out.pml:472 Sent 2    -> queue 41 (ret)
775:    proc 15 (proposer_handler:1) test_out.pml:396 Recv 2    <- queue 41 (ret2)
791:    proc 19 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 90 (__LEARNED)
Never claim moves to line 5     [(!(!((final_value==42))))]
Never claim moves to line 16    [(1)]
807:    proc 26 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 47 (__ACCEPT)
813:    proc 26 (accept_handler:1) test_out.pml:291 Send 10,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 48 (__ACCEPTED)
815:    proc 15 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 90 (__LEARNED)
823:    proc 32 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 90 (__LEARNED)
spin: _spin_nvr.tmp:15, Error: assertion violated
spin: text of failed assertion: assert(!((final_value==31)))
Never claim moves to line 15    [assert(!((final_value==31)))]
spin: trail ends after 826 steps
\end{lstlisting}

\subsubsection{Second paxos implementation with a bug}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
    import VaeLib

    defmodule Acceptor do
    
      @spec start_acceptor() :: :ok
      def start_acceptor do
        acceptedProposal = -1
        acceptedValue = -1
        minProposal = -1
        accept_handler(acceptedProposal, acceptedValue, minProposal)
      end
    
      @spec accept_handler(integer(), integer(), integer()) :: :ok
      def accept_handler(acceptedProposal, acceptedValue, minProposal) do
        receive do
          {:prepare, n, proposer} ->
            if n > minProposal do
              send proposer, {:promise, acceptedProposal, acceptedValue}
              accept_handler(acceptedProposal, acceptedValue, n)
            else
              send proposer, {:promise, acceptedProposal, acceptedValue}
              accept_handler(acceptedProposal, acceptedValue, minProposal)
            end
          {:accept, n, value, proposer} ->
            if n >= minProposal do
              send proposer, {:accepted, n}
              accept_handler(n, value, n)
            else
              send proposer, {:accepted, minProposal}
              accept_handler(acceptedProposal, acceptedValue, minProposal)
            end
          {:terminate} ->
            IO.puts("Terminating acceptor")
        end
      end
    end
    
    defmodule Proposer do
      @spec start_proposer() :: :ok
      def start_proposer do
        receive do
          {:bind, acceptors, proposal_n, value, maj, learner} -> proposer_handler(acceptors, proposal_n, value, maj, learner)
        end
      end
    
      @spec proposer_handler(list(), integer(), integer(), integer(), integer()) :: :ok
      def proposer_handler(acceptors, proposal_n, value, maj, learner) do
        for acceptor <- acceptors do
          send acceptor, {:prepare, proposal_n, self()}
        end
    
        receive_prepared(proposal_n, value, maj, 0, 0)
        {prepared_n, prepared_value} = receive do
          {:majority_prepared, n, v} -> {n, v}
        end
    
        for acceptor <- acceptors do
          send acceptor, {:accept, prepared_n, prepared_value, self()}
        end
    
        accepted_n = receive_accepted(maj, prepared_n, 0, 0)
    
        if accepted_n != -1 do
          # Value chosen
          send learner, {:learned, prepared_value}
        else
          # Value was rejected
          send learner, {:learned, 0}
        end
      end
    
      @spec receive_prepared(integer(), integer(), integer(), integer(), integer()) :: :ok
      def receive_prepared(proposal_n, value, maj, highest_seen_proposal, count) do
        if count >= maj do
          send self(), {:majority_prepared, proposal_n, value}
        else
          receive do
            {:promise, acceptedProposal, acceptedValue} ->
              if acceptedProposal > highest_seen_proposal do
                receive_prepared(acceptedProposal, acceptedValue, maj, acceptedProposal, count + 1) # BUG IS HERE
              else
                receive_prepared(proposal_n, value, maj, highest_seen_proposal, count + 1)
              end
          end
        end
      end
    
      @spec receive_accepted(integer(), integer(), integer(), integer()) :: integer()
      def receive_accepted(maj, prepared_n, rejections, count) do
        if count >= maj do
          if rejections >= 1 do
            -1
          else
            prepared_n
          end
        else
          receive do
            {:accepted, n} ->
              if n > prepared_n do
                receive_accepted(maj, prepared_n, rejections + 1, count + 1)
              else
                receive_accepted(maj, prepared_n, rejections, count + 1)
              end
          end
        end
      end
    end
    
    defmodule Learner do
    
      @spec start() :: :ok
      @vae_init true
      def start do
        n_acceptors = 3
        quorum = 2
        n_proposers = 2
        vals = [42, 31]
        acceptors = for _ <- 1..n_acceptors do
          spawn(Acceptor, :start_acceptor, [])
        end
    
        for i <- 1..n_proposers do
          proposer = spawn(Proposer, :start_proposer, [])
          val_i = i - 1
          val = Enum.at(vals, val_i)
          send proposer, {:bind, acceptors, i, val, quorum, self()}
        end
        wait_learned(acceptors, n_proposers, 0)
      end
    
      @spec wait_learned(list(), integer(), integer()) :: :ok
      @ltl "[]((p->!<>q) && (q->!<>p))"
      @ltl "<>(r)"
      @ltl "[](s)"
      def wait_learned(acceptors, p_n, learned_n) do
        if p_n == learned_n do
          for acceptor <- acceptors do
            send acceptor, {:terminate}
          end
        else
          receive do
            {:learned, final_value} ->
              predicate p, final_value == 31
              predicate q, final_value == 42
              predicate r, final_value != 0
              predicate s, final_value == 0 || final_value == 31 || final_value == 42
              IO.puts("Learned final_value:")
              IO.puts(final_value)
          end
          wait_learned(acceptors, p_n, learned_n + 1)
        end
      end
    end
\end{lstlisting}

\subsubsection{Second paxos bug message log}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
    ltl ltl_1: [] (((! ((final_value==31))) || (! (<> ((final_value==42))))) && ((! ((final_value==42))) || (! (<> ((final_value==31))))))
    ltl ltl_2: <> ((final_value!=0))
    ltl ltl_3: [] ((((final_value==0)) || ((final_value==31))) || ((final_value==42)))
    starting claim 8
    Never claim moves to line 6     [(1)]
    132:    proc  0 (:init::1) test_out.pml:521 Send 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 20 (__BIND)
    138:    proc  7 (start_proposer:1) test_out.pml:314 Recv 7,BIND,0,0,2,0,0,0,0,0,1,0,0,0,0,0,42,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 20 (__BIND)
    154:    proc  8 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    158:    proc  8 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    162:    proc  8 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 23 (__PREPARE)
    197:    proc  6 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    203:    proc  6 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    205:    proc  9 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
    227:    proc  4 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    233:    proc  4 (accept_handler:1) test_out.pml:272 Send 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    235:    proc 10 (receive_prepared:1) test_out.pml:425 Recv 7,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 26 (__PROMISE)
    300:    proc  0 (:init::1) test_out.pml:521 Send 13,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       -> queue 20 (__BIND)
    308:    proc 13 (start_proposer:1) test_out.pml:314 Recv 13,BIND,0,0,3,0,0,0,0,0,2,0,0,0,0,0,31,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 20 (__BIND)
    324:    proc 15 (proposer_handler:1) test_out.pml:350 Send 1,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    328:    proc 15 (proposer_handler:1) test_out.pml:350 Send 3,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    332:    proc 15 (proposer_handler:1) test_out.pml:350 Send 5,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 23 (__PREPARE)
    355:    proc 14 (accept_handler:1) test_out.pml:262 Recv 3,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    361:    proc 14 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
    363:    proc 12 (receive_prepared:1) test_out.pml:421 Send 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 -> queue 42 (__MAJORITY_PREPARED)
    365:    proc  8 (proposer_handler:1) test_out.pml:363 Recv 7,MAJORITY_PREPARED,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 42 (__MAJORITY_PREPARED)
    413:    proc  8 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    417:    proc  8 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    421:    proc  8 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 43 (__ACCEPT)
    458:    proc 16 (receive_prepared:1) test_out.pml:425 Recv 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
    474:    proc  2 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    486:    proc 11 (accept_handler:1) test_out.pml:262 Recv 5,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    492:    proc 11 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 26 (__PROMISE)
    510:    proc 18 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    518:    proc 18 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    520:    proc 17 (receive_prepared:1) test_out.pml:425 Recv 13,PROMISE,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 <- queue 26 (__PROMISE)
    542:    proc 19 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 58 (__ACCEPTED)
    548:    proc 20 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 43 (__ACCEPT)
    556:    proc 20 (accept_handler:1) test_out.pml:296 Send 7,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    570:    proc  2 (accept_handler:1) test_out.pml:291 Send 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 58 (__ACCEPTED)
    586:    proc 24 (receive_prepared:1) test_out.pml:421 Send 13,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        -> queue 42 (__MAJORITY_PREPARED)
    588:    proc 23 (receive_accepted:1) test_out.pml:459 Recv 7,ACCEPTED,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   <- queue 58 (__ACCEPTED)
    600:    proc 15 (proposer_handler:1) test_out.pml:363 Recv 13,MAJORITY_PREPARED,0,0,2,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        <- queue 42 (__MAJORITY_PREPARED)
    610:    proc 15 (proposer_handler:1) test_out.pml:386 Send 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    614:    proc 15 (proposer_handler:1) test_out.pml:386 Send 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    618:    proc 15 (proposer_handler:1) test_out.pml:386 Send 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 43 (__ACCEPT)
    655:    proc 26 (accept_handler:1) test_out.pml:282 Recv 5,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    661:    proc 27 (receive_accepted:1) test_out.pml:454 Send 1    -> queue 65 (ret)
    665:    proc 23 (receive_accepted:1) test_out.pml:471 Recv 1    <- queue 65 (ret2)
    667:    proc 21 (accept_handler:1) test_out.pml:282 Recv 3,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    673:    proc 26 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    675:    proc 23 (receive_accepted:1) test_out.pml:472 Send 1    -> queue 52 (ret)
    677:    proc 21 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    679:    proc 25 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0      <- queue 23 (__PREPARE)
    687:    proc 25 (accept_handler:1) test_out.pml:278 Send 7,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     -> queue 26 (__PROMISE)
    699:    proc 27 (receive_accepted:1) test_out.pml:459 Recv 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 58 (__ACCEPTED)
    723:    proc 19 (receive_accepted:1) test_out.pml:466 Recv 1    <- queue 52 (ret1)
    737:    proc 31 (receive_accepted:1) test_out.pml:459 Recv 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  <- queue 58 (__ACCEPTED)
    755:    proc 30 (accept_handler:1) test_out.pml:262 Recv 1,PREPARE,0,0,2,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 23 (__PREPARE)
    761:    proc 32 (receive_accepted:1) test_out.pml:454 Send 2    -> queue 93 (ret)
    765:    proc 30 (accept_handler:1) test_out.pml:272 Send 13,PROMISE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 26 (__PROMISE)
    767:    proc 19 (receive_accepted:1) test_out.pml:467 Sent 1    -> queue 22 (ret)
    768:    proc  8 (proposer_handler:1) test_out.pml:396 Recv 1    <- queue 22 (ret2)
    772:    proc 31 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 93 (ret2)
    780:    proc  8 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 100 (__LEARNED)
    782:    proc 22 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 100 (__LEARNED)
    788:    proc 32 (accept_handler:1) test_out.pml:282 Recv 1,ACCEPT,0,0,2,0,0,0,0,0,31,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0     <- queue 43 (__ACCEPT)
    794:    proc 32 (accept_handler:1) test_out.pml:291 Send 13,ACCEPTED,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    -> queue 58 (__ACCEPTED)
    796:    proc 31 (receive_accepted:1) test_out.pml:472 Send 2    -> queue 79 (ret)
    798:    proc 27 (receive_accepted:1) test_out.pml:471 Recv 2    <- queue 79 (ret2)
    800:    proc 27 (receive_accepted:1) test_out.pml:472 Sent 2    -> queue 41 (ret)
    801:    proc 15 (proposer_handler:1) test_out.pml:396 Recv 2    <- queue 41 (ret2)
    Never claim moves to line 5     [(!(!((final_value==42))))]
    Never claim moves to line 16    [(1)]
    805:    proc 15 (proposer_handler:1) test_out.pml:401 Send 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   -> queue 100 (__LEARNED)
    817:    proc 33 (wait_learned:1) test_out.pml:558 Recv 0,LEARNED,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0       <- queue 100 (__LEARNED)
    spin: _spin_nvr.tmp:15, Error: assertion violated
    spin: text of failed assertion: assert(!((final_value==31)))
    Never claim moves to line 15    [assert(!((final_value==31)))]
    spin: trail ends after 820 steps
\end{lstlisting}

\section{Consistent Hash Table}
\subsubsection{Working Consistent Hash Table}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule ConsistentHashRing do
  
    @spec start_ring(list(), integer()) :: :ok
    def start_ring(nodes, n) do
      node_positions = Enum.map(nodes, fn n -> hash(n) end)
      ring_handler(nodes, node_positions, n)
    end
  
    @spec ring_handler(list(), list(), integer()) :: :ok
    defp ring_handler(nodes, node_positions, n) do
      receive do
        {:lookup, key, sender} ->
          position = hash(key)
          node = find_closest_node(nodes, node_positions, position, 0, n)
          send sender, {:ring_pos, node}
          ring_handler(nodes, node_positions, n)
  
        {:add_node, node, sender} ->
          new_nodes = nodes ++ [node]
          new_node_position = hash(node)
          new_node_positions = node_positions ++ [new_node_position]
          send sender, {:node_accepted}
          ring_handler(new_nodes, new_node_positions, n + 1)
  
        {:terminate} ->
          IO.puts("Terminating ring handler")
      end
    end
  
    @spec find_closest_node(list(), list(), integer(), integer(), integer()) :: integer()
    defp find_closest_node(nodes, node_positions, position, i, n) do
      if i >= n do
        Enum.at(nodes, 0)
      else
        check_node = Enum.at(nodes, i)
        check_pos = Enum.at(node_positions, i)
  
        if check_pos >= position do
          check_node
        else
          find_closest_node(nodes, node_positions, position, i + 1, n)
        end
      end
    end
  
    @spec hash(integer()) :: integer()
    defp hash(key) do
      # Example hardcoded hash values for keys and nodes
      case key do
        # Keys
        42 -> 1
        25 -> 8
        31 -> 10
  
        # Nodes
        1 -> 2
        2 -> 5
        3 -> 9
        4 -> 15
      end
    end
  end
  
  defmodule Client do
  
    @vae_init true
    @spec start() :: :ok
    @ltl "[](r1 -> <>(p1))"
    @ltl "[](r2 -> <>(p3))"
    @ltl "[](r3 && n_nodes==3 -> <>(p1))"
    @ltl "[](r3 && n_nodes==4 -> <>(p4))"
    def start do
      n_nodes = 3
      nodes = for i <- 1..n_nodes do
        i
      end
      ring = spawn(ConsistentHashRing, :start_ring, [nodes, n_nodes])
  
      next_key = 42
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 42 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 25
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 25 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      # Dynamically grow the ring
      send ring, {:add_node, 4, self()}
      n_nodes = n_nodes + 1
  
      receive do
        {:node_accepted} ->
          IO.puts("Node 4 added to the ring")
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      predicate p1, ring_position == 1
      predicate p2, ring_position == 2
      predicate p3, ring_position == 3
      predicate p4, ring_position == 4
      predicate r1, next_key == 42
      predicate r2, next_key == 25
      predicate r3, next_key == 31
  
      send ring, {:terminate}
    end
  end  
\end{lstlisting}

\subsubsection{Promela for Consistent Hash Table}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Promela of consistent hash table}, label={lst:dht_promela}]
int n_nodes;
int ring_position;
#define p1 ((ring_position == 1))
#define p2 ((ring_position == 2))
#define p3 ((ring_position == 3))
#define p4 ((ring_position == 4))
int next_key = 42;
#define r1 ((next_key == 42))
#define r2 ((next_key == 25))
#define r3 ((next_key == 31))

proctype __anonymous_0 (int n; chan ret; int __pid) {
chan ret1 = [1] of { int }; /*7*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
run hash(n, ret1, __pid); /*7*/
int __ret_placeholder_1; /*7*/
ret1 ? __ret_placeholder_1; /*7*/
ret ! __ret_placeholder_1; /*7*/
}

proctype start_ring (int nodes;int n; chan ret; int __pid) {
chan __anonymous_ret_0 = [0] of { int };
chan ret2 = [1] of { int }; /*8*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
int node_positions;
__get_next_memory_allocation(node_positions);
atomic {
int __iter;
__iter = 0;
do
:: __iter >= LIST_LIMIT -> break;
:: else ->
if
:: LIST_ALLOCATED(nodes, __iter) ->
run __anonymous_0(LIST_VAL(nodes, __iter),__anonymous_ret_0,__pid);
LIST_ALLOCATED(node_positions, __iter) = true;
__anonymous_ret_0 ? LIST_VAL(node_positions, __iter);
__iter++;
:: else -> __iter++;
fi
od
}
int __temp_cp_arr_0;
__copy_memory_to_next(__temp_cp_arr_0, nodes);
int __temp_cp_arr_1;
__copy_memory_to_next(__temp_cp_arr_1, node_positions);
run ring_handler(__temp_cp_arr_0,__temp_cp_arr_1,n, ret2, __pid); /*8*/
}

proctype ring_handler (int nodes;int node_positions;int n; chan ret; int __pid) {
chan ret1 = [0] of { int }; /*15*/
chan ret2 = [0] of { int }; /*16*/
chan ret3 = [1] of { int }; /*18*/
chan ret4 = [0] of { int }; /*22*/
chan ret5 = [1] of { int }; /*25*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
MessageList rec_v_0; /*13*/
do /*13*/
:: __LOOKUP ?? eval(__pid),LOOKUP, rec_v_0 -> /*14*/
int key; /*14*/
key = rec_v_0.m1.data2; /*14*/
int sender; /*14*/
sender = rec_v_0.m2.data2; /*14*/
int position;
position = run hash(key, ret1, __pid); /*15*/
ret1 ? position; /*15*/
int node;
int __temp_cp_arr_2;
__copy_memory_to_next(__temp_cp_arr_2, nodes);
int __temp_cp_arr_3;
__copy_memory_to_next(__temp_cp_arr_3, node_positions);
node = run find_closest_node(__temp_cp_arr_2,__temp_cp_arr_3,position,0,n, ret2, __pid); /*16*/
ret2 ? node; /*16*/
MessageList msg_0; /*17*/
msg_0.m1.data2 = node; /*17*/
__RING_POS !! sender,RING_POS, msg_0; /*17*/
int __temp_cp_arr_4;
__copy_memory_to_next(__temp_cp_arr_4, nodes);
int __temp_cp_arr_5;
__copy_memory_to_next(__temp_cp_arr_5, node_positions);
run ring_handler(__temp_cp_arr_4,__temp_cp_arr_5,n, ret3, __pid); /*18*/
break;
:: __ADD_NODE ?? eval(__pid),ADD_NODE, rec_v_0 -> /*20*/
node = rec_v_0.m1.data2; /*20*/
sender = rec_v_0.m2.data2; /*20*/
int new_nodes;
__get_next_memory_allocation(new_nodes);
__list_append_list(new_nodes, nodes);
__list_append(new_nodes, node);
int new_node_position;
new_node_position = run hash(node, ret4, __pid); /*22*/
ret4 ? new_node_position; /*22*/
int new_node_positions;
__get_next_memory_allocation(new_node_positions);
__list_append_list(new_node_positions, node_positions);
__list_append(new_node_positions, new_node_position);
MessageList msg_1; /*24*/
__NODE_ACCEPTED !! sender,NODE_ACCEPTED, msg_1; /*24*/
int __temp_cp_arr_6;
__copy_memory_to_next(__temp_cp_arr_6, new_nodes);
int __temp_cp_arr_7;
__copy_memory_to_next(__temp_cp_arr_7, new_node_positions);
run ring_handler(__temp_cp_arr_6,__temp_cp_arr_7,n + 1, ret5, __pid); /*25*/
break;
:: __TERMINATE ?? eval(__pid),TERMINATE, rec_v_0 -> /*27*/
printf("Terminating ring handler\n");
break;
od;
}

proctype find_closest_node (int nodes;int node_positions;int position;int i;int n; chan ret; int __pid) {
chan ret1 = [1] of { int }; /*43*/
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
if
:: (i >= n) -> /*0*/
ret ! __list_at(nodes, 0)
:: else ->
int check_node;
check_node = __list_at(nodes, i)
int check_pos;
check_pos = __list_at(node_positions, i)
if
:: (check_pos >= position) -> /*0*/
ret ! check_node; /*41*/
:: else ->
int __temp_cp_arr_8;
__copy_memory_to_next(__temp_cp_arr_8, nodes);
int __temp_cp_arr_9;
__copy_memory_to_next(__temp_cp_arr_9, node_positions);
run find_closest_node(__temp_cp_arr_8,__temp_cp_arr_9,position,i + 1,n, ret1, __pid); /*43*/
int __ret_placeholder_1; /*43*/
ret1 ? __ret_placeholder_1; /*43*/
ret ! __ret_placeholder_1; /*43*/
fi;
fi;
}

proctype hash (int key; chan ret; int __pid) {
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
do
:: key == 42 ->
ret ! 1; /*0*/
break;
:: key == 25 ->
ret ! 8; /*0*/
break;
:: key == 31 ->
ret ! 10; /*0*/
break;
:: key == 1 ->
ret ! 2; /*0*/
break;
:: key == 2 ->
ret ! 5; /*0*/
break;
:: key == 3 ->
ret ! 9; /*0*/
break;
:: key == 4 ->
ret ! 15; /*0*/
break;
od
}

active proctype start () {
chan ret1 = [1] of { int };
int __pid = 0;
if
::__pid==-1 -> __pid = _pid;
::else->skip;
fi;
n_nodes = 3;
int nodes;
__get_next_memory_allocation(nodes);
int i;
for(i : 1 .. n_nodes) { /*76*/
int __tmp;
__tmp = i; /*77*/
__list_append(nodes, __tmp);
}
int ring;
atomic {
ring = run start_ring(nodes,n_nodes,ret1,-1); /*79*/
}
MessageList msg_0; /*82*/
msg_0.m1.data2 = next_key; /*82*/
msg_0.m2.data2 = __pid; /*82*/
__LOOKUP !! ring,LOOKUP, msg_0; /*82*/
MessageList rec_v_1; /*83*/
do /*83*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_1 -> /*0*/
int node; /*0*/
node = rec_v_1.m1.data2; /*0*/
printf("Key 42 is assigned to\n");
printf("node\n");
ring_position = node; /*87*/
break;
od;
next_key = 25;
MessageList msg_1; /*91*/
msg_1.m1.data2 = next_key; /*91*/
msg_1.m2.data2 = __pid; /*91*/
__LOOKUP !! ring,LOOKUP, msg_1; /*91*/
MessageList rec_v_2; /*92*/
do /*92*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_2 -> /*0*/
node = rec_v_2.m1.data2; /*0*/
printf("Key 25 is assigned to\n");
printf("node\n");
ring_position = node; /*96*/
break;
od;
next_key = 31;
MessageList msg_2; /*100*/
msg_2.m1.data2 = next_key; /*100*/
msg_2.m2.data2 = __pid; /*100*/
__LOOKUP !! ring,LOOKUP, msg_2; /*100*/
MessageList rec_v_3; /*101*/
do /*101*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_3 -> /*0*/
node = rec_v_3.m1.data2; /*0*/
printf("Key 31 is assigned to\n");
printf("node\n");
ring_position = node; /*105*/
break;
od;
MessageList msg_3; /*109*/
msg_3.m1.data2 = 4; /*109*/
msg_3.m2.data2 = __pid; /*109*/
__ADD_NODE !! ring,ADD_NODE, msg_3; /*109*/
n_nodes = n_nodes + 1; 
MessageList rec_v_4; /*112*/
do /*112*/
:: __NODE_ACCEPTED ?? eval(__pid),NODE_ACCEPTED, rec_v_4 -> /*113*/
printf("Node 4 added to the ring\n");
break;
od;
next_key = 31;
MessageList msg_4; /*118*/
msg_4.m1.data2 = next_key; /*118*/
msg_4.m2.data2 = __pid; /*118*/
__LOOKUP !! ring,LOOKUP, msg_4; /*118*/
MessageList rec_v_5; /*119*/
do /*119*/
:: __RING_POS ?? eval(__pid),RING_POS, rec_v_5 -> /*0*/
node = rec_v_5.m1.data2; /*0*/
printf("Key 31 is assigned to\n");
printf("node\n");
ring_position = node; /*123*/
break;
od;
MessageList msg_5; /*134*/
__TERMINATE !! ring,TERMINATE, msg_5; /*134*/
}


ltl ltl_1 { [](r1 -> <>(p1)) };
ltl ltl_2 { [](r2 -> <>(p3)) };
ltl ltl_3 { [](r3 && n_nodes==3 -> <>(p1)) };
ltl ltl_4 { [](r3 && n_nodes==4 -> <>(p4)) };

\end{lstlisting}

\subsubsection{Buggy Consistent Hash Table}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule ConsistentHashRingB do
  
    @spec start_ring(list(), integer()) :: :ok
    def start_ring(nodes, n) do
      node_positions = Enum.map(nodes, fn n -> hash(n) end)
      ring_handler(nodes, node_positions, n)
    end
  
    @spec ring_handler(list(), list(), integer()) :: :ok
    defp ring_handler(nodes, node_positions, n) do
      receive do
        {:lookup, key, sender} ->
          position = hash(key)
          node = find_closest_node(nodes, node_positions, position, 0, n)
          send sender, {:ring_pos, node}
          ring_handler(nodes, node_positions, n)
  
        {:add_node, node} ->
          new_nodes = nodes ++ [node]
          new_node_position = hash(node)
          new_node_positions = node_positions ++ [new_node_position]
          ring_handler(new_nodes, new_node_positions, n + 1)
  
        {:terminate} ->
          IO.puts("Terminating ring handler")
      end
    end
  
    @spec find_closest_node(list(), list(), integer(), integer(), integer()) :: integer()
    defp find_closest_node(nodes, node_positions, position, i, n) do
      if i >= n do
        Enum.at(nodes, 0)
      else
        check_node = Enum.at(nodes, i)
        check_pos = Enum.at(node_positions, i)
  
        if check_pos >= position do
          check_node
        else
          find_closest_node(nodes, node_positions, position, i + 1, n)
        end
      end
    end
  
    @spec hash(integer()) :: integer()
    defp hash(key) do
      # Example hardcoded hash values for keys and nodes
      case key do
        # Keys
        42 -> 1
        25 -> 8
        31 -> 10
  
        # Nodes
        1 -> 2
        2 -> 5
        3 -> 9
        4 -> 15
      end
    end
  end
  
  defmodule ClientB do
  
    @vae_init true
    @spec start() :: :ok
    @ltl "[](r1 -> <>(p1))"
    @ltl "[](r2 -> <>(p3))"
    @ltl "[](r3 && n_nodes==3 -> <>(p1))"
    @ltl "[](r3 && n_nodes==4 -> <>(p4))"
    def start do
      n_nodes = 3
      nodes = for i <- 1..n_nodes do
        i
      end
      ring = spawn(ConsistentHashRingB, :start_ring, [nodes, n_nodes])
  
      next_key = 42
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 42 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 25
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 25 is assigned to")
          IO.puts node
          node
      end
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      # Dynamically grow the ring
      send ring, {:add_node, 4}
      n_nodes = n_nodes + 1
  
      next_key = 31
      send ring, {:lookup, next_key, self()}
      ring_position = receive do
        {:ring_pos, node} ->
          IO.puts("Key 31 is assigned to")
          IO.puts node
          node
      end
  
      predicate p1, ring_position == 1
      predicate p2, ring_position == 2
      predicate p3, ring_position == 3
      predicate p4, ring_position == 4
      predicate r1, next_key == 42
      predicate r2, next_key == 25
      predicate r3, next_key == 31
  
      send ring, {:terminate}
    end
  end
  
\end{lstlisting}
  
\subsubsection{Buggy Hash Table Logs}

\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
The program is livelocked, or an ltl property was violated. Generating trace.
<<<Message Events>>>
[1] (hash:1) send [2]
[2] (__anonymous_0:1) recv [2]
[3] (start_ring:1) recv [2]
[4] (hash:1) send [5]
[5] (__anonymous_0:1) recv [5]
[6] (start_ring:1) recv [5]
[7] (hash:1) send [9]
[8] (__anonymous_0:1) recv [9]
[9] (start_ring:1) recv [9]
[10] (start:1) send [1,LOOKUP,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[11] (ring_handler:1) recv [1,LOOKUP,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[12] (ring_handler:1) recv [1]
[13] (ring_handler:1) recv [1]
[14] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[15] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[16] (start:1) send [1,LOOKUP,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[17] (ring_handler:1) recv [1,LOOKUP,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[18] (ring_handler:1) recv [8]
[19] (find_closest_node:1) send [3]
[20] (find_closest_node:1) recv [3]
[21] (find_closest_node:1) send [3]
[22] (find_closest_node:1) recv [3]
[23] (ring_handler:1) recv [3]
[24] (ring_handler:1) send [0,RING_POS,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[25] (start:1) recv [0,RING_POS,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[26] (start:1) send [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[27] (ring_handler:1) recv [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[28] (ring_handler:1) recv [10]
[29] (find_closest_node:1) send [1]
[30] (find_closest_node:1) recv [1]
[31] (find_closest_node:1) send [1]
[32] (find_closest_node:1) recv [1]
[33] (find_closest_node:1) send [1]
[34] (find_closest_node:1) recv [1]
[35] (ring_handler:1) recv [1]
[36] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[37] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[38] (start:1) send [1,ADD_NODE,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[39] (start:1) send [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[40] (ring_handler:1) recv [1,LOOKUP,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[41] (ring_handler:1) recv [10]
[42] (find_closest_node:1) send [1]
[43] (find_closest_node:1) recv [1]
[44] (find_closest_node:1) send [1]
[45] (find_closest_node:1) recv [1]
[46] (find_closest_node:1) send [1]
[47] (find_closest_node:1) recv [1]
[48] (ring_handler:1) recv [1]
[49] (ring_handler:1) send [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[50] (ring_handler:1) recv [1,ADD_NODE,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[51] (ring_handler:1) recv [15]
[52] (start:1) recv [0,RING_POS,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[53] (start:1) send [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[54] (ring_handler:1) recv [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{lstlisting}

\section{Two-Phase Commit}
\subsubsection{LTLixir 2PC}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  import VaeLib

  defmodule Coordinator do
    @spec start_coordinator(list(), integer(), integer(), integer()) :: :ok
    def start_coordinator(participants, transaction_id, value, n_participants) do
      coordinator_handler(participants, transaction_id, value, 0, n_participants)
    end
  
    @spec coordinator_handler(list(), integer(), integer(), integer(), integer()) :: :ok
    defp coordinator_handler(participants, transaction_id, value, phase, n_participants) do
      case phase do
        0 -> # Phase 1: Prepare
          for participant <- participants do
            send participant, {:prepare, transaction_id, value, self()}
          end
          receive_prepare_responses(participants, transaction_id, value, 0, 0, n_participants)
        1 -> # Phase 2: Commit
          for participant <- participants do
            send participant, {:commit, transaction_id, self()}
          end
          wait_for_acks(participants, 0, n_participants, 1)
      end
    end
  
    @spec receive_prepare_responses(list(), integer(), integer(), integer(), integer(), integer()) :: :ok
    defp receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants) do
      if count >= n_participants do
        if acks == n_participants do
          coordinator_handler(participants, transaction_id, value, 1, n_participants)
        else
          IO.puts("Transaction aborted")
          for participant <- participants do
            send participant, {:abort, transaction_id, self()}
          end
          wait_for_acks(participants, 0, n_participants, 0)
        end
      else
        receive do
          {:prepared, response_transaction_id, participant} ->
            if response_transaction_id == transaction_id do
              receive_prepare_responses(participants, transaction_id, value, count + 1, acks + 1, n_participants)
            else
              receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants)
            end
          {:abort, response_transaction_id, participant} ->
            if response_transaction_id == transaction_id do
              receive_prepare_responses(participants, transaction_id, value, count + 1, acks, n_participants)
            else
              receive_prepare_responses(participants, transaction_id, value, count, acks, n_participants)
            end
        end
      end
    end
  
    @spec wait_for_acks(list(), integer(), integer(), integer()) :: :ok
    defp wait_for_acks(participants, count, n_participants, committed) do
      if count >= n_participants do
        if committed == 1 do
          IO.puts("Transaction committed")
        end
        for participant <- participants do
          send participant, {:terminate}
        end
      else
        receive do
          {:ack, _participant} ->
            wait_for_acks(participants, count + 1, n_participants, committed)
        end
      end
    end
  end
  
  defmodule Participant do
    @spec start_participant(integer()) :: :ok
    def start_participant(client) do
      participant_handler(client)
    end
  
    @spec participant_handler(integer()) :: :ok
    defp participant_handler(client) do
      receive do
        {:prepare, transaction_id, value, coordinator} ->
          prepare = decide_to_prepare(value)
          if prepare do
            send coordinator, {:prepared, transaction_id, self()}
          else
            send coordinator, {:abort, transaction_id, self()}
          end
          participant_handler(client)
        {:commit, transaction_id, coordinator} ->
          commit(transaction_id, client)
          send coordinator, {:ack, self()}
          participant_handler(client)
        {:abort, transaction_id, coordinator} ->
          abort(transaction_id, client)
          send coordinator, {:ack, self()}
          participant_handler(client)
        {:terminate} ->
          IO.puts("Terminating participant")
      end
    end
  
    @spec decide_to_prepare(integer()) :: boolean()
    defp decide_to_prepare(value) do
      # Example decision logic i.e. ensure all locks are required to make the commit
      # We use some arbitrary random logic
      cmps = [10, 90]
      cmp = Enum.random(cmps)
      if value < cmp do
        true
      else
        false
      end
    end
  
    @spec commit(integer(), integer()) :: :ok
    defp commit(transaction_id, client) do
      IO.puts("Committing transaction")
      send client, {:transaction_commit}
    end
  
    @spec abort(integer(), integer()) :: :ok
    defp abort(transaction_id, client) do
      IO.puts("Aborting transaction")
      send client, {:transaction_abort}
  
    end
  end
  
  defmodule Client do
    @vae_init true
    @spec start() :: :ok
    def start do
      n_participants = 3
      participants = for _ <- 1..n_participants do
        spawn(Participant, :start_participant, [self()])
      end
  
      transaction_id = 1
      value = 42
      coordinator = spawn(Coordinator, :start_coordinator, [participants, transaction_id, value, n_participants])
  
      await_transaction_result(0, 0, n_participants)
    end
  
    @spec await_transaction_result(integer(), integer(), integer()) :: :ok
    @ltl "<>[]p || <>[]q"
    @ltl "[](p -> !<>[]q)"
    @ltl "[](q -> !<>[]p)"
    def await_transaction_result(n_c, n_a, n_p) do
      commit_count = n_c
      abort_count = n_a
      participant_count = n_p
      predicate p, commit_count == participant_count
      predicate q, abort_count == participant_count
      if n_c + n_a >= n_p do
        IO.puts("All participants have responded")
      else
        receive do
          {:transaction_commit} ->
            await_transaction_result(n_c + 1, n_a, n_p)
          {:transaction_abort} ->
            await_transaction_result(n_c, n_a + 1, n_p)
        end
      end
    end
  end
  
\end{lstlisting}

\subsubsection{Buggy 2PC Logs}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Message passing caused by the proposer's protocol bug.}, label={lst:paxos_bug}]
The program is livelocked, or an ltl property was violated. Generating trace.
<<<Message Events>>>
[1] (coordinator_handler:1) send [1,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[2] (coordinator_handler:1) send [3,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[3] (coordinator_handler:1) send [5,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[4] (participant_handler:1) recv [5,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[5] (participant_handler:1) recv [1]
[6] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[7] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[8] (participant_handler:1) recv [3,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[9] (participant_handler:1) recv [1]
[10] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[11] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[12] (participant_handler:1) recv [1,PREPARE,0,0,1,0,0,0,0,0,42,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[13] (participant_handler:1) recv [1]
[14] (participant_handler:1) send [7,PREPARED,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[15] (receive_prepare_responses:1) recv [7,PREPARED,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[16] (coordinator_handler:1) send [1,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[17] (coordinator_handler:1) send [3,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[18] (coordinator_handler:1) send [5,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[19] (participant_handler:1) recv [3,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[20] (commit:1) send [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[21] (participant_handler:1) send [7,ACK,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[22] (wait_for_acks:1) recv [7,ACK,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[23] (participant_handler:1) recv [5,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[24] (commit:1) send [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[25] (participant_handler:1) send [7,ACK,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[26] (wait_for_acks:1) recv [7,ACK,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[27] (participant_handler:1) recv [1,COMMIT,0,0,1,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[28] (commit:1) send [0,TRANSACTION_ABORT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[29] (participant_handler:1) send [7,ACK,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[30] (wait_for_acks:1) recv [7,ACK,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[31] (wait_for_acks:1) send [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[32] (wait_for_acks:1) send [3,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[33] (wait_for_acks:1) send [5,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[34] (participant_handler:1) recv [1,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[35] (participant_handler:1) recv [5,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[36] (participant_handler:1) recv [3,TERMINATE,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[37] (await_transaction_result:1) recv [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[38] (await_transaction_result:1) recv [0,TRANSACTION_COMMIT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
[39] (await_transaction_result:1) recv [0,TRANSACTION_ABORT,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{lstlisting}

\section{Dining Philosophers}
\subsubsection{Dining Philosophers Deadlock Logs}
\begin{lstlisting}[xleftmargin=.01\linewidth, xrightmargin=0.01\linewidth, caption={Dining Philosophers Verlixir Report.}, label={lst:dp_bug}]
  The program likely reached a deadlock. Generating trace.
  <<<Message Events>>>
  [1] (start:1) send [4,BIND,0,0,1,0,0,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [2] (start_phil:1) recv [4,BIND,0,0,1,0,0,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [3] (phil_loop:1) send [1,SIT,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [4] (table_loop:1) recv [1,SIT,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [5] (table_loop:1) send [4,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [6] (wait:1) recv [4,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [7] (wait:1) send [0]
  [8] (phil_loop:1) recv [0]
  [9] (phil_loop:1) send [2,PICKUP,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [10] (start:1) send [2,LPHIL,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [11] (start_fork:1) recv [2,LPHIL,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [12] (start:1) send [3,RPHIL,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [13] (start:1) send [5,BIND,0,0,1,0,0,0,0,0,3,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [14] (start_phil:1) recv [5,BIND,0,0,1,0,0,0,0,0,3,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [15] (phil_loop:1) send [1,SIT,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [16] (table_loop:1) recv [1,SIT,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [17] (table_loop:1) send [5,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [18] (wait:1) recv [5,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [19] (wait:1) send [0]
  [20] (phil_loop:1) recv [0]
  [21] (phil_loop:1) send [3,PICKUP,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [22] (start:1) send [3,LPHIL,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [23] (start_fork:1) recv [3,LPHIL,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [24] (start_fork:1) recv [3,RPHIL,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [25] (fork_loop:1) recv [3,PICKUP,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [26] (fork_loop:1) send [5,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [27] (wait:1) recv [5,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [28] (wait:1) send [0]
  [29] (phil_loop:1) recv [0]
  [30] (phil_loop:1) send [2,PICKUP,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [31] (start:1) send [2,RPHIL,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [32] (start_fork:1) recv [2,RPHIL,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [33] (fork_loop:1) recv [2,PICKUP,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [34] (fork_loop:1) send [4,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [35] (wait:1) recv [4,OK,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  [36] (wait:1) send [0]
  [37] (phil_loop:1) recv [0]
  [38] (phil_loop:1) send [3,PICKUP,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  
  <<<Error Trace>>>
  [1] (proc_0) start:120 [send lfork, {:lphil, phil}]
  [2] (proc_4) start_phil:20 [end]
  [3] (proc_6) phil_loop:27 [wait()]
  [4] (proc_1) table_loop:0 []
  [5] (proc_1) table_loop:6 [table_loop()]
  [6] (proc_7) wait:53 [end]
  [8] (proc_6) phil_loop:28 []
  [9] (proc_6) phil_loop:31 [wait()]
  [10] (proc_0) start:121 [send rfork, {:rphil, phil}]
  [11] (proc_2) start_fork:0 []
  [12] (proc_0) start:122 [end]
  [13] (proc_0) start:120 [send lfork, {:lphil, phil}]
  [14] (proc_5) start_phil:20 [end]
  [15] (proc_9) phil_loop:27 [wait()]
  [16] (proc_8) table_loop:0 []
  [17] (proc_8) table_loop:6 [table_loop()]
  [18] (proc_10) wait:53 [end]
  [20] (proc_9) phil_loop:28 []
  [21] (proc_9) phil_loop:31 [wait()]
  [22] (proc_0) start:121 [send rfork, {:rphil, phil}]
  [23] (proc_3) start_fork:0 []
  [24] (proc_3) start_fork:0 []
  [25] (proc_12) fork_loop:0 []
  [26] (proc_12) fork_loop:76 [fork_loop(1, lphil, rphil)]
  [27] (proc_10) wait:53 [end]
  [29] (proc_9) phil_loop:32 [IO.puts "lfork"]
  [30] (proc_9) phil_loop:35 [wait()]
  [31] (proc_0) start:122 [end]
  [32] (proc_2) start_fork:0 []
  [33] (proc_15) fork_loop:0 []
  [34] (proc_15) fork_loop:76 [fork_loop(1, lphil, rphil)]
  [35] (proc_7) wait:53 [end]
  [37] (proc_6) phil_loop:32 [IO.puts "lfork"]
  [38] (proc_6) phil_loop:35 [wait()]
  [39] (proc_17) wait:52 [{:ok} -> :ok]
  [40] (proc_16) fork_loop:86 [{:putdown, phil} ->]
  [41] (proc_15) fork_loop:77 [else]
  [42] (proc_14) wait:52 [{:ok} -> :ok]
  [43] (proc_13) fork_loop:86 [{:putdown, phil} ->]
  [44] (proc_12) fork_loop:77 [else]
  [45] (proc_11) table_loop:4 [{:sit, phil} ->]
  [47] (proc_9) phil_loop:36 [IO.puts "rfork"]
  [48] (proc_8) table_loop:7 [{:leave, phil} ->]
  [50] (proc_6) phil_loop:36 [IO.puts "rfork"]
  [51] (proc_5) start_phil:20 [end]
  [52] (proc_4) start_phil:20 [end]
  [53] (proc_3) start_fork:64 [end]
  [54] (proc_2) start_fork:64 [end]
  [55] (proc_1) table_loop:7 [{:leave, phil} ->]
  [56] (proc_0) start:126 [{:done} -> :ok]
\end{lstlisting}

\subsubsection{Dining Philosophers in Elixir}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
defmodule Table do
  @spec table_loop() :: :ok
  def table_loop do
    receive do
      {:sit, phil} ->
        send phil, {:ok}
        table_loop()
      {:leave, phil} ->
        send phil, {:ok}
        table_loop()
      {:terminate} -> :ok
    end
  end
end

defmodule Philosopher do
  @spec start_phil(integer()) :: :ok
  def start_phil(coordinator) do
    receive do
      {:bind, table, lfork, rfork} -> phil_loop(coordinator, table, lfork, rfork)
    end
  end

  @spec phil_loop(integer(), integer(), integer(), integer()) :: :ok
  def phil_loop(coordinator, table, lfork, rfork) do
    # ... think ... #
    send table, {:sit, self()}
    wait()

    # ... sitting ... #
    send lfork, {:pickup, self()}
    wait()
    IO.puts "lfork"

    send rfork, {:pickup, self()}
    wait()
    IO.puts "rfork"

    # ... eating ... #
    send table, {:leave, self()}
    wait()
    send lfork, {:putdown, self()}
    wait()
    send rfork, {:putdown, self()}
    wait()

    send coordinator, {:done}
  end

  @spec wait() :: :ok
  def wait() do
    receive do
      {:ok} -> :ok
    end
  end
end

defmodule Fork do
  @spec start_fork() :: :ok
  def start_fork do
    receive do
      {:lphil, lphil} ->
        receive do
          {:rphil, rphil} -> fork_loop(0, lphil, rphil)
        end
    end
  end

  @spec fork_loop(integer(), integer(), integer()) :: :ok
  def fork_loop(allocated, lphil, rphil) do
    # allocated: 0 => none, 1 => left, 2 => right
    if allocated == 0 do
      receive do
        {:pickup, phil} ->
          if phil == lphil do
            send phil, {:ok}
            fork_loop(1, lphil, rphil)
          else
            send phil, {:ok}
            fork_loop(2, lphil, rphil)
          end
        {:terminate} ->
          :ok
      end
    else
      receive do
        {:putdown, phil} ->
          send phil, {:ok}
          fork_loop(0, lphil, rphil)
        {:terminate} ->
          :ok
      end
    end
  end
end


defmodule Coordinator do
  @vae_init true
  @spec start() :: :ok
  def start do
    n = 4

    table = spawn(Table, :table_loop, [])

    forks = for _ <- 1..n do
      spawn(Fork, :start_fork, [])
    end

    phils = for i <- 1..n do
      spawn(Philosopher, :start_phil, [self()])
    end

    j = n-1
    for i <- 0..j do
      phil = Enum.at(phils,i)
      lfork = Enum.at(forks,i)
      r_i = rem(i+1, n)
      rfork = Enum.at(forks, r_i)
      send phil, {:bind, table, lfork, rfork}
      send lfork, {:lphil, phil}
      send rfork, {:rphil, phil}
    end

    for i <- 1..n do
      receive do
        {:done} -> :ok
      end
    end
    IO.puts "All philosophers have finished eating!"

    for fork <- forks do
      send fork, {:terminate}
    end
    send table, {:terminate}
  end
end

\end{lstlisting}

\subsubsection{Promela Translation of Dining Philosophers}
\begin{lstlisting}[xleftmargin=.001\linewidth, xrightmargin=0.001\linewidth, caption={Dining Philosophers Promela translation.}, label={lst:promela_dp}]
  proctype table_loop (chan ret;int __pid;int __ret_f) {
    chan ret1 = [1] of { int };/* 7*/ /* table_loop()*/ 
    chan ret2 = [1] of { int };/* 10*/ /* table_loop()*/ 
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        MessageList rec_v_0;/* 4*/ /* receive do*/ 
        do/* 4*/ /* receive do*/ 
        :: __SIT??eval(__pid),SIT,rec_v_0 -> /* 0*/ 
            int phil;/* 0*/ 
            phil = rec_v_0.m1.data2;/* 0*/ 
            atomic {
            MessageList msg_0;/* 6*/ /* send phil,{:ok}*/ 
            __OK!!phil,OK,msg_0;/* 6*/ /* send phil,{:ok}*/ 
            }
            int __ret_placeholder_1;/* 7*/ /* table_loop()*/ 
            run table_loop(ret1,__pid,1);/* 7*/ /* table_loop()*/ 
            ret1?__ret_placeholder_1;/* 7*/ /* table_loop()*/ 
            break;
        :: __LEAVE??eval(__pid),LEAVE,rec_v_0 -> /* 0*/ 
            phil = rec_v_0.m1.data2;/* 0*/ 
            atomic {
            MessageList msg_1;/* 9*/ /* send phil,{:ok}*/ 
            __OK!!phil,OK,msg_1;/* 9*/ /* send phil,{:ok}*/ 
            }
            int __ret_placeholder_2;/* 10*/ /* table_loop()*/ 
            run table_loop(ret2,__pid,1);/* 10*/ /* table_loop()*/ 
            ret2?__ret_placeholder_2;/* 10*/ /* table_loop()*/ 
            break;
        :: __TERMINATE??eval(__pid),TERMINATE,rec_v_0 -> /* 11*/ /* {:terminate} -> :ok*/ 
            break;
        od;
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    proctype start_phil (int coordinator;chan ret;int __pid;int __ret_f) {
    chan ret1 = [1] of { int };/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        MessageList rec_v_1;/* 19*/ /* receive do*/ 
        do/* 19*/ /* receive do*/ 
          :: __BIND??eval(__pid),BIND,rec_v_1 -> /* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            int table;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            table = rec_v_1.m1.data2;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            int lfork;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            lfork = rec_v_1.m2.data2;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            int rfork;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            rfork = rec_v_1.m3.data2;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            int __ret_placeholder_1;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            run phil_loop(coordinator,table,lfork,rfork,ret1,__pid,1);/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            ret1?__ret_placeholder_1;/* 20*/ /* {:bind,table,lfork,rfork} -> phil_loop(coordinator,table,lfork,rfork)*/ 
            break;
        od;
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    proctype phil_loop (int coordinator;int table;int lfork;int rfork;chan ret;int __pid;int __ret_f) {
    chan ret1 = [1] of { int };/* 28*/ /* wait()*/ 
    chan ret2 = [1] of { int };/* 32*/ /* wait()*/ 
    chan ret3 = [1] of { int };/* 36*/ /* wait()*/ 
    chan ret4 = [1] of { int };/* 41*/ /* wait()*/ 
    chan ret5 = [1] of { int };/* 43*/ /* wait()*/ 
    chan ret6 = [1] of { int };/* 45*/ /* wait()*/ 
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        atomic {
        MessageList msg_0;/* 27*/ /* send table,{:sit,self()}*/ 
        msg_0.m1.data2 = __pid;/* 27*/ /* send table,{:sit,self()}*/ 
        __SIT!!table,SIT,msg_0;/* 27*/ /* send table,{:sit,self()}*/ 
        }
        int __ret_placeholder_1;/* 28*/ /* wait()*/ 
        run wait(ret1,__pid,1);/* 28*/ /* wait()*/ 
        ret1?__ret_placeholder_1;/* 28*/ /* wait()*/ 
        atomic {
        MessageList msg_1;/* 31*/ /* send lfork,{:pickup,self()}*/ 
        msg_1.m1.data2 = __pid;/* 31*/ /* send lfork,{:pickup,self()}*/ 
        __PICKUP!!lfork,PICKUP,msg_1;/* 31*/ /* send lfork,{:pickup,self()}*/ 
        }
        int __ret_placeholder_2;/* 32*/ /* wait()*/ 
        run wait(ret2,__pid,1);/* 32*/ /* wait()*/ 
        ret2?__ret_placeholder_2;/* 32*/ /* wait()*/ 
        printf("lfork\n");
        atomic {
        MessageList msg_2;/* 35*/ /* send rfork,{:pickup,self()}*/ 
        msg_2.m1.data2 = __pid;/* 35*/ /* send rfork,{:pickup,self()}*/ 
        __PICKUP!!rfork,PICKUP,msg_2;/* 35*/ /* send rfork,{:pickup,self()}*/ 
        }
        int __ret_placeholder_3;/* 36*/ /* wait()*/ 
        run wait(ret3,__pid,1);/* 36*/ /* wait()*/ 
        ret3?__ret_placeholder_3;/* 36*/ /* wait()*/ 
        printf("rfork\n");
        atomic {
        MessageList msg_3;/* 40*/ /* send table,{:leave,self()}*/ 
        msg_3.m1.data2 = __pid;/* 40*/ /* send table,{:leave,self()}*/ 
        __LEAVE!!table,LEAVE,msg_3;/* 40*/ /* send table,{:leave,self()}*/ 
        }
        int __ret_placeholder_4;/* 41*/ /* wait()*/ 
        run wait(ret4,__pid,1);/* 41*/ /* wait()*/ 
        ret4?__ret_placeholder_4;/* 41*/ /* wait()*/ 
        atomic {
        MessageList msg_4;/* 42*/ /* send lfork,{:putdown,self()}*/ 
        msg_4.m1.data2 = __pid;/* 42*/ /* send lfork,{:putdown,self()}*/ 
        __PUTDOWN!!lfork,PUTDOWN,msg_4;/* 42*/ /* send lfork,{:putdown,self()}*/ 
        }
        int __ret_placeholder_5;/* 43*/ /* wait()*/ 
        run wait(ret5,__pid,1);/* 43*/ /* wait()*/ 
        ret5?__ret_placeholder_5;/* 43*/ /* wait()*/ 
        atomic {
        MessageList msg_5;/* 44*/ /* send rfork,{:putdown,self()}*/ 
        msg_5.m1.data2 = __pid;/* 44*/ /* send rfork,{:putdown,self()}*/ 
        __PUTDOWN!!rfork,PUTDOWN,msg_5;/* 44*/ /* send rfork,{:putdown,self()}*/ 
        }
        int __ret_placeholder_6;/* 45*/ /* wait()*/ 
        run wait(ret6,__pid,1);/* 45*/ /* wait()*/ 
        ret6?__ret_placeholder_6;/* 45*/ /* wait()*/ 
        atomic {
        MessageList msg_6;/* 47*/ /* send coordinator,{:done}*/ 
        __DONE!!coordinator,DONE,msg_6;/* 47*/ /* send coordinator,{:done}*/ 
        }
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    proctype wait (chan ret;int __pid;int __ret_f) {
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        MessageList rec_v_2;/* 52*/ /* receive do*/ 
        do/* 52*/ /* receive do*/ 
          :: __OK??eval(__pid),OK,rec_v_2 -> /* 53*/ /* {:ok} -> :ok*/ 
            break;
        od;
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    proctype start_fork (chan ret;int __pid;int __ret_f) {
    chan ret1 = [1] of { int };/* 64*/ /* {:rphil,rphil} -> fork_loop(0,lphil,rphil)*/ 
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        MessageList rec_v_3;/* 61*/ /* receive do*/ 
        do/* 61*/ /* receive do*/ 
          :: __LPHIL??eval(__pid),LPHIL,rec_v_3 -> /* 0*/ 
            int lphil;/* 0*/ 
            lphil = rec_v_3.m1.data2;/* 0*/ 
            MessageList rec_v_4;/* 63*/ /* receive do*/ 
            do/* 63*/ /* receive do*/ 
              :: __RPHIL??eval(__pid),RPHIL,rec_v_4 -> /* 0*/ 
                int rphil;/* 0*/ 
                rphil = rec_v_4.m1.data2;/* 0*/ 
                int __ret_placeholder_1;/* 64*/ /* {:rphil,rphil} -> fork_loop(0,lphil,rphil)*/ 
                run fork_loop(0,lphil,rphil,ret1,__pid,1);/* 64*/ /* {:rphil,rphil} -> fork_loop(0,lphil,rphil)*/ 
                ret1?__ret_placeholder_1;/* 64*/ /* {:rphil,rphil} -> fork_loop(0,lphil,rphil)*/ 
                break;
            od;
            break;
          od;
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    proctype fork_loop (int allocated;int lphil;int rphil;chan ret;int __pid;int __ret_f) {
    chan ret1 = [1] of { int };/* 77*/ /* fork_loop(1,lphil,rphil)*/ 
    chan ret2 = [1] of { int };/* 80*/ /* fork_loop(2,lphil,rphil)*/ 
    chan ret3 = [1] of { int };/* 89*/ /* fork_loop(0,lphil,rphil)*/ 
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        if
        :: (allocated == 0) -> /* 0*/ 
            MessageList rec_v_5;/* 73*/ /* receive do*/ 
            do/* 73*/ /* receive do*/ 
            :: __PICKUP??eval(__pid),PICKUP,rec_v_5 -> /* 0*/ 
                int phil;/* 0*/ 
                phil = rec_v_5.m1.data2;/* 0*/ 
                if
                :: (phil == lphil) -> /* 0*/ 
                    atomic {
                    MessageList msg_0;/* 76*/ /* send phil,{:ok}*/ 
                    __OK!!phil,OK,msg_0;/* 76*/ /* send phil,{:ok}*/ 
                    }
                    int __ret_placeholder_1;/* 77*/ /* fork_loop(1,lphil,rphil)*/ 
                    run fork_loop(1,lphil,rphil,ret1,__pid,1);/* 77*/ /* fork_loop(1,lphil,rphil)*/ 
                    ret1?__ret_placeholder_1;/* 77*/ /* fork_loop(1,lphil,rphil)*/ 
                :: else -> 
                    atomic {
                    MessageList msg_1;/* 79*/ /* send phil,{:ok}*/ 
                    __OK!!phil,OK,msg_1;/* 79*/ /* send phil,{:ok}*/ 
                    }
                    int __ret_placeholder_2;/* 80*/ /* fork_loop(2,lphil,rphil)*/ 
                    run fork_loop(2,lphil,rphil,ret2,__pid,1);/* 80*/ /* fork_loop(2,lphil,rphil)*/ 
                    ret2?__ret_placeholder_2;/* 80*/ /* fork_loop(2,lphil,rphil)*/ 
                fi;
                break;
              :: __TERMINATE??eval(__pid),TERMINATE,rec_v_5 -> /* 82*/ /* {:terminate} -> */ 
                break;
            od;
        :: else -> 
            MessageList rec_v_6;/* 86*/ /* receive do*/ 
            do/* 86*/ /* receive do*/ 
            :: __PUTDOWN??eval(__pid),PUTDOWN,rec_v_6 -> /* 0*/ 
                phil = rec_v_6.m1.data2;/* 0*/ 
                atomic {
                MessageList msg_2;/* 88*/ /* send phil,{:ok}*/ 
                __OK!!phil,OK,msg_2;/* 88*/ /* send phil,{:ok}*/ 
                }
                int __ret_placeholder_3;/* 89*/ /* fork_loop(0,lphil,rphil)*/ 
                run fork_loop(0,lphil,rphil,ret3,__pid,1);/* 89*/ /* fork_loop(0,lphil,rphil)*/ 
                ret3?__ret_placeholder_3;/* 89*/ /* fork_loop(0,lphil,rphil)*/ 
                break;
            :: __TERMINATE??eval(__pid),TERMINATE,rec_v_6 -> /* 90*/ /* {:terminate} -> */ 
                break;
            od;
        fi;
        atomic{
            if
            :: __ret_f -> ret!0;
            :: else -> skip;
            fi;
        }
    }
    
    active proctype start () {
    chan ret1 = [1] of { int };
    chan ret2 = [1] of { int };
    chan ret3 = [1] of { int };
        int __pid = 0;
        atomic{
            if
            :: __pid == - 1 -> __pid = _pid;
            :: else -> skip;
            fi;
        }
        int n = 4;
        int table;
        atomic {
            table = run table_loop(ret1,- 1,0);/* 104*/ /* table = spawn(Table,:table_loop,[])*/ 
        }
        int forks;
        __get_next_memory_allocation(forks);
        for(__dummy_iterator : 1 .. n) {/* 106*/ /* forks = for _ < - 1..n do*/ 
            int __tmp;
            atomic {
                __tmp = run start_fork(ret2,- 1,0);/* 107*/ /* spawn(Fork,:start_fork,[])*/ 
            }
            __list_append(forks,__tmp);
        }
        int phils;
        __get_next_memory_allocation(phils);
        int i;
        for(i : 1 .. n) {/* 110*/ /* phils = for i < - 1..n do*/ 
            int __tmp;
            atomic {
                __tmp = run start_phil(__pid,ret3,- 1,0);/* 111*/ /* spawn(Philosopher,:start_phil,[self()])*/ 
            }
            __list_append(phils,__tmp);
        }
        int j;
        j = n - 1;
        for(i : 0 .. j) {/* 115*/ /* for i < - 0..j do*/ 
            int phil;
            phil = __list_at(phils,i)
            int lfork;
            lfork = __list_at(forks,i)
            int r_i;
            r_i = (i + 1) % (n);/* 118*/ /* r_i = rem(i + 1,n)*/ 
            int rfork;
            rfork = __list_at(forks,r_i)
            atomic {
            MessageList msg_0;/* 120*/ /* send phil,{:bind,table,lfork,rfork}*/ 
            msg_0.m1.data2 = table;/* 120*/ /* send phil,{:bind,table,lfork,rfork}*/ 
            msg_0.m2.data2 = lfork;/* 120*/ /* send phil,{:bind,table,lfork,rfork}*/ 
            msg_0.m3.data2 = rfork;/* 120*/ /* send phil,{:bind,table,lfork,rfork}*/ 
            __BIND!!phil,BIND,msg_0;/* 120*/ /* send phil,{:bind,table,lfork,rfork}*/ 
            }
            atomic {
            MessageList msg_1;/* 121*/ /* send lfork,{:lphil,phil}*/ 
            msg_1.m1.data2 = phil;/* 121*/ /* send lfork,{:lphil,phil}*/ 
            __LPHIL!!lfork,LPHIL,msg_1;/* 121*/ /* send lfork,{:lphil,phil}*/ 
            }
            atomic {
            MessageList msg_2;/* 122*/ /* send rfork,{:rphil,phil}*/ 
            msg_2.m1.data2 = phil;/* 122*/ /* send rfork,{:rphil,phil}*/ 
            __RPHIL!!rfork,RPHIL,msg_2;/* 122*/ /* send rfork,{:rphil,phil}*/ 
            }
        }
        for(i : 1 .. n) {/* 125*/ /* for i < - 1..n do*/ 
            MessageList rec_v_7;/* 126*/ /* receive do*/ 
            do/* 126*/ /* receive do*/ 
            :: __DONE??eval(__pid),DONE,rec_v_7 -> /* 127*/ /* {:done} -> :ok*/ 
                break;
            od;
        }
        printf("All philosophers have finished eating!\n");
        atomic {
            __list_ptr_old = __list_ptr;
            __list_ptr = 0;
            __list_ptr_new = 0;
            do
            :: __list_ptr >= LIST_LIMIT || __list_ptr_new >= LIST_LIMIT -> 
                __list_ptr = __list_ptr_old;
                break;
            :: else -> 
                if
                :: LIST_ALLOCATED(forks,__list_ptr) -> 
                    int fork;
                    fork = LIST_VAL(forks,__list_ptr);
                    atomic {
                    MessageList msg_3;/* 133*/ /* send fork,{:terminate}*/ 
                    __TERMINATE!!fork,TERMINATE,msg_3;/* 133*/ /* send fork,{:terminate}*/ 
                    }
                    ;
                    __list_ptr_new++;
                    __list_ptr++;
                :: else -> __list_ptr++;
                fi
            od
        }
        atomic {
        MessageList msg_4;/* 135*/ /* send table,{:terminate}*/ 
        __TERMINATE!!table,TERMINATE,msg_4;/* 135*/ /* send table,{:terminate}*/ 
        }
    }    
\end{lstlisting}

\section{Raft}

\subsubsection{Raft Consensus in Elixir}
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
  defmodule RaftNode do
  @spec start_node(integer(), integer(), integer()) :: :ok
  def start_node(id, n_peers, client) do
    peers = receive do
      {:bind, peers} -> peers
    end
    term = 10 * id
    node_handler(id, peers, n_peers, 0, term, 0, client)
  end

  @spec node_handler(integer(), list(), integer(), atom(), integer(), integer(), integer()) :: :ok
  defp node_handler(id, peers, n_peers, state, term, vote_count, client) do
    receive do
      {:request_vote, candidate_term, candidate_id, reply_to} ->
        if candidate_term > term do
          send(reply_to, {:vote_granted, id})
          node_handler(id, peers, n_peers, 0, candidate_term, vote_count, client)
        else
          node_handler(id, peers, n_peers, state, term, vote_count, client)
        end

      {:vote_granted, _voter_id} ->
        new_vote_count = vote_count + 1
        if state == 1 and new_vote_count >= n_peers / 2 + 1 do
          send(client, {:elected, term})
          for peer <- peers do
            send(peer, {:append_entries, term, id}) # Send log here
          end
          node_handler(id, peers, n_peers, 2, term, new_vote_count, client)
        else
          node_handler(id, peers, n_peers, state, term, new_vote_count, client)
        end

      {:start_election} ->
        for peer <- peers do
          send(peer, {:request_vote, term + 1, id, self()})
        end
        node_handler(id, peers, n_peers, 1, term + 1, 0, client)

      {:terminate} ->
        IO.puts("Terminating node")

      after 1000 ->
        send self(), {:start_election}
        node_handler(id, peers, n_peers, state, term, 0, client)
    end
  end
end

defmodule Client3 do
  @vae_init true
  @spec start() :: :ok
  @ltl """
  !<>[](elected_term == previously_elected_term)
  """
  def start do
    # follower -> 0, candidate -> 1, leader -> 2
    n_nodes = 3
    n_peers = n_nodes - 1
    rounds = 2
    previously_elected_term = -1
    elected_term = 0
    nodes = for id <- 1..n_nodes do
      spawn(RaftNode, :start_node, [id, n_peers, self()])
    end

    for p_id <- nodes do
      send(p_id, {:bind, nodes})
    end

    for _ <- 1..rounds do
      {elected_term, previously_elected_term} = receive do
        {:elected, term} ->
          IO.puts("Node elected")
          {term, elected_term}
      end
    end

    for p_id <- nodes do
      send(p_id, {:terminate})
    end
  end
end
\end{lstlisting}