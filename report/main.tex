\documentclass[a4paper, twoside]{report}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{lmodern}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{backnaur}
\usepackage{geometry}
\usepackage{longtable}
\usepackage{array}
\usepackage{tcolorbox}
\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\usepackage{booktabs}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

% Code blocks
\definecolor{dkgreen}{RGB}{0,128,0} % Define the dkgreen color using RGB values
\lstset{
  frame=none,
  language=Promela,
  aboveskip=5mm,
  belowskip=5mm,
  showstringspaces=false,
  columns=flexible,
  xleftmargin=.3\textwidth,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{orange},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left, 
  captionpos=b, 
}

% Elixir code colouring
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{108,48,130}
\definecolor{weborange}{RGB}{255,165,0}
\definecolor{frenchplum}{RGB}{129,20,83}

\lstdefinelanguage{elixir}{
    morekeywords={case,catch,def,defv,pre,post,do,else,false,%
        use,alias,receive,timeout,defmacro,defp,%
        for,if,import,defmodule,defprotocol,%
        nil,defmacrop,defoverridable,defimpl,%
        super,fn,raise,true,try,end,with,%
        unless, quote, unquote},
    otherkeywords={<-,->, |>, \%\{, \}, \{, \, (, )},
    sensitive=true,
    morecomment=[l]{\#},
    morecomment=[n]{/*}{*/},
    morecomment=[s][\color{purple}]{:}{\ },
    morestring=[s][\color{orange}]"",
    commentstyle=\color{commentgreen},
    keywordstyle=\color{eminence},
    stringstyle=\color{red},
	basicstyle=\ttfamily,
	breaklines,
	showstringspaces=false,
	frame=none,
    escapeinside={(*@}{@*)}
}
\lstdefinestyle{promela}{
    language=C,
    morekeywords={proctype, init, chan},
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    captionpos=b,
    tabsize=2
}
\lstdefinelanguage{dafny}{
    morekeywords={method, function, class, var, assert, ensures, requires, modifies, decreases, new, if, else, while, break, return, ghost, forall, exists, invariant, axiom, datatype},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    commentstyle=\color{green},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily,
    breaklines,
    showstringspaces=false,
    frame=none
}
\lstdefinelanguage{boogie}{
    morekeywords={implementation, procedure, assert, assume, havoc, call, return, var, function, modifies, ensures, requires, if, else, while, break, continue},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    commentstyle=\color{green},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily,
    breaklines,
    showstringspaces=false,
    frame=none
}
\lstdefinelanguage{none}{}

\title{Verlixir: Verification of Message-Passing Systems}
\author{Matthew Neave}
% Update supervisor and other title stuff in title/title.tex

\begin{document}
\input{title/title.tex}

\begin{abstract}
    Distributed algorithms are difficult to prove and reason about. With the rapid rise in cloud-based clusters, the need for developing robust distributed algorithms is seen as a critical requirement by service providers and has sparked new interest in developing tools for reasoning about distributed algorithms.
    \\ \\
    This project proposes and evaluates Verlixir, a verification-aware language for specifying and verifying message-passing systems. Verlixir supports three modes of operation. Simulation mode can be used to execute and observe the system in a controlled environment. Verification mode can verify the system against a set of properties. Finally, parameterization mode can be used to guarantee the system behaves across different configurations.
    \\ \\
    A qualitative evaluation of Verlixir demonstrates the capability to detect violations of properties in distributed algorithms, such as Paxos and Two-Phase Commit. Verlixir enhances Elixir programs with linear temporal logic properties, predicates and function contracts to specify the desired behaviour of systems. Property violations produce Elixir-friendly counterexamples that can be used to debug the system. Counterexamples show process interleaving and message-passing interleaving that results in a property violation.
    \\ \\
    Verlixir enables developers to define message-passing systems in terms of safety and liveness. Distributed algorithms can be prototyped and verified in a safe environment. Verlixir replaces the need for writing complex models in bespoke specification languages, which have to be maintained alongside implementation in modern programming languages. This is all achieved while maintaining the original program semantics, such that, after verification, the system can be run in production.
\end{abstract}
\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
I am grateful to my supervisor, Dr. Naranker Dulay, for his guidance and support throughout this project. 
\\ \\
My sincerest gratitude goes to my family, for their continued support through my studies.
\\ \\
Finally, a word of thanks to my friends, for their encouragement and motivation.
\end{abstract}

\tableofcontents
% \listoffigures
% \lstlistoflistings
% \listoftables

% \input{introduction/introduction.tex}
\input{plan/introduction.tex}
\input{background/background.tex}
\input{elixir/elixir.tex}
\input{project/project.tex}
\input{implementation/implementation.tex}
\input{evaluation/evaluation.tex}
\input{conclusion/conclusion.tex}
% \input{plan/project_plan.tex}
% \input{plan/evaluation.tex}
\input{bibs/references.tex}
\input{appendix/appendix.tex}

% \bibliographystyle{alpha}
% \bibliography{bibs/sample}

\end{document}