\chapter{Design of Veriflixir}
This chapter provides an in-depth insight into the design decisions that were made during the development of Veriflixir and LTLixir. The chapter will begin by providing a high-level overview of where the relevant components fit into the toolchain, as well as providing an architectural overview of the tool. Section \ref{sec:specification_language} will discuss the design of LTLixir, section \ref{sec:modelling_elixir_programs} will describe the main techniques Veriflixir applies in the analysis and modeling of a specification. Finally, section \ref{sec:simulation_verification} will describe the derivations of the outputs generated by Veriflixir.  
\section{Veriflixir Toolchain} \label{sec:toolchain}
Toolchain:
LTLixir -> Veriflixir -> Spin -> Veriflixir -> Output
|-> BEAM byte-code -> beam 

Architecture:
Elixir program
Elixir parser
IR representation
Promela writer
Instrumentors (modelrunner/modelgenerator)
File writer
Spin model checker
Violationhandlers
Trace generator
Output

\section{Specification Language} \label{sec:specification_language}

vae\_init
ltl
params
defv
pre- and post-
predicates

\section{Modelling Elixir Programs} \label{sec:modelling_elixir_programs}
The primary work done by Veriflixir is determining how to internally represent an Elixir program. Given an Elixir program, with an inlined specification following the LTLixir semantics, Veriflixir must both model the system and the properties of the specification. This section will outline the techniques used to achieve this.
\subsection{High-level Overview}
The internals of how the system is used to produce models of Elixir programs can be categorized into three umbrellas:
\begin{itemize}
    \item \textbf{Parsing}: given an Elixir program, generate a quoted expression that represents the program and performs lexical analysis and parsing on the quoted expression.
    \item \textbf{Intermediate Representation}: given a parsed tree of the quoted expression, generate an intermediate representation by extracting features relevant to model the program and specification.
    \item \textbf{Writing}: take the intermediate representation and generate a model in a target language.
\end{itemize} 
The writer currently only supports the generation of Promela models, which can be verified using the model checker Spin, see section \ref{sec:simulation_verification}. Although this component of Veriflixir can be split into these three stages, as they all work to achieve the same goal we will treat them as one and consider this component the \texttt{model generator}. The remainder of this section will discuss the techniques applied in the model generator, and specifically how the generator targets Promela as an output language.
\subsection{Sequential Execution} \label{sec:sequential_execution}
First, we explore how to model sequential execution. Elixir relies on a few parent identifers that generally describe the structure of a program. We discuss a few flavors of these:
\begin{itemize}
    \item \textbf{Blocks}: blocks are a simple but core concept. An Elixir block contains multiple Elixir expressions separated by newlines or semi-colons.
    \item \textbf{Modules}: multiple functions can be grouped together in a module. All Elixir code runs inside processes, so typically grouping functions in a module is a way to group functions that are related to the task a process performs.
    \item \textbf{Do}: Elixir control structures such as \texttt{if} and \texttt{receive} all use the \texttt{do} keyword as syntactic sugar for a new expression. The child expression could be a single expression or a nested block.
\end{itemize}
These three constructs are examples of the primary building blocks of an Elixir program. With each, a new level of scope is introduced. Declared variables from parent scopes are accessible in child scopes, but any match to re-assign a variable from the parent scope will not persist. Instead, the structure of an Elixir program expects you to match the variable to the child scope, and return the attended assignment to the parent scope. Assuming there is no assignment to these constructs, then constructing a model is straightforward, we can derive the parent-child hierarchy directly. We hold multiple types of symbol tables, to represent the different constructs such as modules, functions and blocks. Within these symbol table types, we further can assign child symbol tables to account for the nesting of these scoped constructs.
\par
TODO DIAGRAM OF THE TYPES OF SYMBOL TABLES AND THEIR HIERARCHY
\par
\subsubsection{Traversal, Scoping and Variable Declarations}
Of course, that assumed a variable was not assigned to the child scope. In this case, we are required to track the execution of a scope in more detail. Let's first re-iterate Elixir's \texttt{match} operator and describe how the model generator handles it. Every expression in Elixir returns a value, and hence every expression can be matched on. We can match the entire return value of an expression to a single identifier, or use pattern matching to either have more granular control on how the return value is matched. We could also form guards for more complex checks used in conditional statements (such as \texttt{if} and \texttt{receive}). Elixir is a dynamically, strongly typed language. Dynamic typing enforces restrictions on the set of Elixir expressions we support. Strong typing helps type inference in model generation. In the intermediate representation (IR), a match is represented as either a declaration or an assignment. Given a declaration to an integer, we can infer the variable type and assign this in the symbol table. Now the variable is declared, any subsequent match in the same scope level is considered an assignment. If this assignment's inferred type does not align with the declared type, we raise an error.
\par
If we now match on an expression that introduces a new child scope (such as a receive or if), we must explore every possible branch, determine the returning expression of the branch and use the relevant identifiers to assign the return value to the parent scope. To achieve this, the expression is traversed in using a depth-first search with a stack of lists. The stack manages the scope levels and the list manages the variable identifiers. Let's explore an example.
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth, caption={Representing variable declarations using the match operator}.]
    {player, action} = receive do
        {:move, player, direction} -> {player, "moved #{direction}"}
        {:attack, player, target} -> 
            send health, {target, -2}
            {player, "attacked #{target}"}
    end
\end{lstlisting}
In the example, we are matching on a tuple. We push $player$ and $action$ to the identifier list and then descend into the first guard (conditioned by the \texttt{:move} atom). This is a singular expression, so it must be the return value of this guard. We can peek the scope stack to access the list of variables, and iterate through them assigning the relevant values. Assuming this is a declaration, we also add the identifiers to the current scopes symbol table. We can mark direction as a $string$ as this is easily inferred, but we leave $player$ as $unknown$ until we can gather more information about the type. We now traverse the second branch. This follows the \texttt{block} construct, so we require pushing an empty list to the stack. We recursively apply this process until we reach the last expression in the block. Reaching the last expression, we can pop the stack (removing the child scope level) and then peek the stack to access the list of variables from the parent scope. We assign these using the same method, this time asserting the types align with the symbol table, or inferring more information about $unknown$ types if possible.
TODO DIAGRAM ON THE STACKS?
\par
\subsubsection{Functions, Type Specifications and Return Types}
Like the other constructs, functions introduce a new scope level. Multiple functions within a module and can be used to determine the control flow for a process. Before we discuss about the how functions are represented, we must quickly discuss types again. A correct LTLixir specification should provide type information for all function arguments and the return type. These properties are used to aid the type inference. The return type also determines how we model our function. If the return type is \texttt{:ok}, the function is non-returning, and we can treat the function as a standard sequential execution (but with its own local internal representation). If a return type is provided, we use a similar technique by recursively traversing expressions to determine all exit points of the function. 
\par
Promela does not support functions. We model functions using Promela processes and rendezvous communication channels. To implement functions using our writer, we apply various techniques that mimick how Elixir functions behave. Firstly, the caller must declare a new rendezvous communication channel (using a buffer size of 0). A rendezvous channel has no buffer and hence communication over the channel is entirely synchronous. We also declare a new variable to store the return value of the function, typed using the type specification of the callee. We can now spawn a new process (a process mocking the function) and pass two imperative arguments alongside the arguments specified in the Elixir function. We first pass the channel, which acts as both a return value and signaling method for the function termination. We also pass a process identifier. All processes are identified by this process id; by passing this to the callee, the callee can take actions as if it were the parent process in communication. We then pass the remaining arguments as if we were making a true function call. The caller will now block until the callee sends a message over the signaling channel. The callee can proceed as normal, and by using the discussed traversal techniques, all exit points will send the final expression over the signaling channel. This approach easily extends to recursion, as the callee can spawn a new instance of itself and block until a signal is received.
\par
TODO DIAGRAM OF RECURSIVE FUNCTION CALLS.
\par 
\subsection{Concurrent Memory Model} \label{sec:memory_model}
Now we have explored the basics of modeling Elixir programs, we extend the ideas to programs with multiple processes running concurrently. To correctly design a model of a concurrent Elixir system, there are a few core principles we must capture.
\begin{itemize}
    \item Spawning processes.
    \item Sending messages.
    \item Receiving messages.
    \item Bounding communication.
\end{itemize}
We will first explain how we model the spawning of a new process, before taking a deeper look into more interesting concurrency primitives as well as a memory model to extend the existing capabilities of Promela. The Veriflixir IR for spawning processes resembles the Elixir spawn very closely. We capture a function that acts as the entry to the process which we can then model as a Promela process. As with a function call, we pass a process identifier to the new child process. In this case, the process identifier is a reserved identifier that signals to the new process to take a unique process identifier assigned automatically by the system. This is an important mechanism to ensure all parents are uniquely identifiable, which is crucial for communication. This process identifier can be captured in the caller's symbol table and used to communicate with the process.
\par
TODO DIAGRAM OF FUNCTION CALL VS SPAWN AND HOW IT IMPACTS PID
\par

\subsubsection{Actors, Mailboxes and Message Passing}
Once we have another process's identifier in our symbol table, we can begin communication between processes. Elixir implements this communication using the actor model, where each running process in the system is an actor that can send messages and receive messages using a mailbox. The mailbox can be considered a first-in-first-fireable-out queue. The IR must capture this ordering, otherwise it could misrepresent the execution of an Elixir program.
\par
We begin by describing the design of a message. A message is comprised of two components, the \texttt{message type} and the \texttt{message body}. In Elixir, the message type is denoted with an atom, which the IR simply treats as a distinct type within the system. When the message type is used in the context of a send or receive it is added to a global set of message types. Tracking this set globally is important to model the entirety of the system, even if in reality, the message type has different meanings in local contexts. The message body consists of multiple message arguments. At this point, the IR does not refer to the message argument by its type but purely treats it as an argument that is expected to be passed in communication. We can store any primitive type within a message argument by inferring the type from the send or receive expression. If a type cannot be inferred in the context, we reserve a byte array to store the message argument, but to avoid this causing memory issues, we limit the size of the byte array to a small fixed size.
\par
Now that we can construct a message, we can begin to model how messages can be sent and received. The IR keeps close to the mailbox system the actor-based implementation uses. Using the global message type set, we construct a per-process mailbox for each message type. The per-process mailboxes are packed into an arrays of mailboxes, where the index of the array aligns with the process identifiers we had previously been allocating. When a process sends a message, we triage which mailbox the message should be sent to using the message type and use the process identifier from the symbol table to index into the correct communication channel to attach the message.
\par
TODO EXAMPLE OF SENDING A MESSAGE TO ONE OF THE PROCESS' MAILBOXES
\par
Receiving a message is a little more complex. We must now consider complex pattern matching in guard conditions. To begin pattern matching, we can again use the message type system to determine which mailbox to check. If more than just the message type is required in the pattern matching of a guard, we must preempt elements of the message body to determine which elements are important for pattern matching and which elements are identifiers that need assignments. In order to generate a model for the guards, we introduce a blocking statement consisting of multiple conditions. When one of the conditions is satisfied (i.e. a message has been pattern-matched) we stop blocking, execute the block relevant for the matched guard and then break out of the control structure. Before we can execute the block, we must assign all the remaining identifiers from the receive guard to the relevant values in the received message body. To do this, we first introduce a new dummy variable which is assigned the value of the entire message body. We can then access the dummy variable to assign the remaining identifiers from the guard. During the assignment, we have no indication of the type of the identifier. Hence, we can temporarily assign a message argument to the identifier, and extract the correct attribute from the message argument when we have more information about the type. A note on typing: the IR considers message types interchangeable with integers, hence comparisons can be made between the two which can be useful for matching. Sending messages is a non-blocking operation, unlike when we used rendezvous channels to model functions, if we send a message and do not care about receiving a returning message, we can continue executing the process body.
\par
Unlike Elixir actors, Veriflixir bounds multiple communication primitives. This is to ensure state explosion in the model checker is less likely to occur. As mentioned, we are strict in the bounding of byte arrays that can be passed as message arguments. We also only supply a small number of mailboxes per message type, furthermore, we bound the number of messages that can buffer in a per-process mailbox.
\subsubsection{Dynamic Memory Allocation COME BACK TO}

elixir lists grow dynamically
promela does not support this
fixed sized lists that dynamically hold more elements
how arrays are implemented using dynamic memory
reading and writing to arrays
using higher order functions to interact with arrays (map ,random , for, )
anonymous functions
for comprehension (different types i.e. range, list)

\subsection{Supporting LTLixir} \label{sec:supporting_ltl}

extracting ltl expressions
extracting vae\_init
parameterization
defv
pre- and post-conditions (attachment in correct place, must ensure no operations take place after the post condition, guarntee its the last thing)
predicates


\section{Simulation and Verification} \label{sec:simulation_verification}

all passable parameters to exe
passing line numbers
reading elixir files, matching promela to elixir
extracting traces

\subsection{Simulation}
\subsection{Verification}
\subsection{Parameterization}

model generation

\section{Summary, Limitations and Future Work}
