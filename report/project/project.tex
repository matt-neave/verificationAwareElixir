\chapter{Verlixir} \label{chap:verlixir}
Verlixir is the main project contribution. Verlixir is designed such that, Elixir programmers get deadlock safety guarantees for free. To strengthen the system guarantees, programmers can write inline specifications and function contracts. 
\\ \\
Verlixir supports three modes of operation: simulation, verification and parameterized verification. Simulation mode is used to run a single execution of the system. Verification mode is used to verify the system adheres to the provided specification. Parameterized verification is used to verify the system over multiple configurations.
\\ \\
This chapter aims to inform the reader of the constructs defined in Verlixir. Section \ref{sec:ltlixir} introduces the Verlixir language. Section \ref{sec:verifiable} provides an example of specifying a verifiable system and how Verlixir can be used to detect violations of a specification. The subsequent subsections provide further details of more features of Verlixir, such as specifying temporal properties.
\\ \\
\section{LTLixir} \label{sec:ltlixir}
LTLixir is the multi-purpose specification language that compiles to BEAM byte-code and is supported for verification by Verlixir. Primarily, LTLixir is a subset of Elixir, supporting both sequential and concurrent execution. This subset is expressive enough to implement well-known distributed algorithms such as basic Paxos \cite{basic_paxos} and the alternating-bit protocol \cite{ab_protocol}. LTLixir extends Elixir with constructs for specifying temporal properties, specifically LTL properties (where LTLixir derives its name) as well as function contracts for specifying pre- and post-conditions. Specifications can be parameterized to identify violations of properties on specific configurations. 
\\ \\
\section{Constructing a Verifiable Elixir Program} \label{sec:verifiable}
This section will walk through the basic construction of a Verlixir program, and show how we can verify the properties of the program using Verlixir. To begin, we define a server and client process. The server is responsible for creating clients and communicating with them. 
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Elixir definition for a server and client module}., label={fig:basic_server}]
    defmodule Server do
        def start_server do
            client = spawn(Client, :start_client, [])
        end
    end

    defmodule Client do
        def start_client do
            IO.puts "Client booted"
        end
    end
\end{lstlisting}
Given the implementation, we must now declare an entry point to the system, that Verlixir will use to begin verification. For this example, we can define \texttt{Server.server\_start} as the entry point using \textbf{\@init}.

\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Declaring an entry point to the system}., label={fig:init}]
    (*@\fbox{@init}@*)
    def start_server do
        client = spawn(Client, :start_client, [])
    end
\end{lstlisting}
With an entry point specified, we can begin using the available tools. By default, Verlixir reports the presence of deadlocks and livelocks in the system. When specifying systems in Verlixir, we do not lose the capability to compile our program to BEAM byte-code, hence the system can still run as a regular Elixir program.
\\ \\
More interestingly, we can now use Verlixir before the Erlang Run-Time System (ERTS) to verify the system adheres to our specification. With no additional properties defined, by running Verlixir, we are ensuring that every possible execution results in a program termination. The presence of a deadlock or livelock will be reported. We first run a simulation of the system.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -s basic_example.ex 
    Client booted
\end{lstlisting}
Alternatively, we can run the verifier on the specification.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -v basic_example.ex 
    Model checking ran successfully. 0 error(s) found.
    The verifier terminated with no errors.
\end{lstlisting}
\subsection{Detecting a Deadlock} \label{sec:deadlock}
Now we have a basic understanding of what is required to write a specification, we will use Verlixir to detect a deadlock in the system. Deadlocks in Elixir programs can be introduced by circular waits, where two simultaneously executing processes, are both waiting for a message from the other. 
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={A simple Elixir system with a deadlock}.]
defmodule Server do
    (*@\fbox{@init}@*)
    def start_server do
        client = spawn(Client, :start_client, [])
        receive do
            {:im_alive} -> IO.puts "Client is alive"
        end
    end
  end
  
defmodule Client do
    def start_client do
        receive do
        {:binding} -> IO.puts "Client bound"
        end
    end
end  
\end{lstlisting}
In this example, any execution of the system will result in a deadlock; the system can be considered deterministic in this regard. In many real-world systems with multiple processes, the presence of a deadlock can be difficult to detect due to multiple interleavings.
\\ \\
A simulation of the system using Verlixir will report a timeout (something which the ERTS would not report). Already, running our specification using Verlixir, provides more information than running the Elixir program. Let's now run the verifier.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    The program likely reached a deadlock. Generating trace.
    [8] (proc_0) start_server:4 [receive do]
    [9] (proc_0) start_server:4 [receive do]
    [10] (proc_0) start_server:5 [{:im_alive} -> IO.puts "Client is alive"]
    [13] (proc_1) start_client:13 [{:binding} -> IO.puts "Client bound"]
    <<< END OF TRAIL, FINAL STATES: >>>
    [14] (proc_1) start_client:13 [{:binding} -> IO.puts "Client bound"]
    [15] (proc_0) start_server:5 [{:im_alive} -> IO.puts "Client is alive"]
\end{lstlisting}
If an error is found, Verlixir will profile the type of error; in this case, it has determined the program likely deadlocked. Once determining the error type, an error trace is produced to debug the source of the error. The underlying model derived from the Verlixir specification does not have a one-to-one mapping to the original Elixir code, hence, heuristics are applied, to determine where in the Elixir program the trail is produced from.
\\ \\
Alongside the process name, we can see the line number in the Elixir file. The remaining information on a trail line is less relevant to most users. The first number on a line is the step number (some of these may be omitted for simplicity). The \texttt{proc\_n} refers either to a process number or function call stack depth.
\\ \\
Alongside the error trace, Verlixir also reports a trace of all messages being sent and received through the system. If we take a look at the messages produced in this case, we see that no messages were ever sent. This could give a further indication as to why the deadlock has arisen.
\\ \\
We can read the trail in sequential order to learn the interleaving that resulted in the error. In this instance, we can see the server reaches line 5 where it waits for an \texttt{:im\_alive} message from the client and similarly, the client is waiting for a \texttt{:binding} message.
\subsection{Linear Temporal Logic}
We now introduce Linear Temporal Logic (LTL) to our systems to allow us to write more interesting Verlixir specifications.
\\ \\
Let's re-design the server and client processes, so we can introduce temporal properties to reason about. The server will now spawn $n$ clients, bind the clients to itself and then await a response from all three clients.
\begin{lstlisting}[language=Elixir, xleftmargin=.2\linewidth]
    def start_server do
        client_n = 3
        alive_clients = 0
        for _ <- 1..client_n do
            client = spawn(Client, :start_client, [])
            send(client, {:bind, self()})
        end
        alive_clients = check_clients(client_n, alive_clients)
    end
\end{lstlisting}
The implementation of the client process and the \texttt{check\_clients/2} function have been omitted. Without understanding their implementation, we can still use our specification to verify the system acts as intended. We introduce our first LTL formula, which verifies that eventually, the number of alive clients is equal to $n$. To introduce an LTL formula, we can use \textbf{@ltl}. An LTL formula is assigned, as a string, to a function. The LTL grammar is defined as the following.
\begin{bnf*}
    \bnfprod{ltl}
      {\bnfpn{operand} \bnfor ( \bnfpn{ltl} ) \bnfor \bnfpn{ltl} \bnfpn{binop} \bnfpn{ltl} \bnfor \bnfpn{unop} \bnfpn{ltl}}\\
    \bnfprod{operand}
      {true \bnfor false \bnfor var \bnfor int \bnfor elixir\_expr}\\
    \bnfprod{unop}
      {\square \bnfor \lozenge \bnfor !}\\
    \bnfprod{binop}
      {U \bnfor W \bnfor V \bnfor \&\& \bnfor || \bnfor \rightarrow \bnfor \leftrightarrow }\\
\end{bnf*}
We want to verify that eventually, the number of alive clients equals the number the server created. We can write this using the formula $\lozenge (alive\_clients \equiv client\_n)$. Using the LTL attribute, we can update our server process.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Example LTL property}]
    @init true
    @spec start_server() :: :ok
    (*@\fbox{@ltl "<>(alive\_clients == client\_n)"}@*)
    def start_server do
        ...
    end
\end{lstlisting}
Let us run Verlixir on the system.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 0 error(s) found.
    The verifier terminated with no errors.
\end{lstlisting}
We can update the LTL formula, by replacing \texttt{clients\_n} with the number 1 ($\lozenge (alive\_clients \equiv 1)$). We run the verifier again.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    The program is livelocked, or an LTL property was violated. Generating trace.
    ... trace omitted ...
\end{lstlisting}
To help with readability, we can define inline predicates to use in LTL formulae. The predicates that can be defined are formed from a subset of the LTL grammar, without the temporal modalities. Inline predicates can refer to variables in the scope of the function. For example, we can define a predicate \( all\_alive \) as $alive\_clients \equiv client\_n$. Using this predicate, we can strengthen our LTL formula to \( (!all\_alive) \ \mathcal{U} \ (\square all\_alive) \). Informally, this formula states that there is a moment in time where $alive\_clients \equiv client\_n$, and from that moment onwards, this property holds until termination. We can update our \texttt{start\_server} function to reflect this.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    (*@\fbox{@ltl "(!all\_alive)U([]all\_alive)"}@*)
    def start_server do
      client_n = 3
      alive_clients = 0
      (*@\fbox{predicate all\_alive, alive\_clients == client\_n}@*)
      ...
    end
\end{lstlisting}
\subsection{Contracts} 
Verlixir also supports Design by Contracts, using pre- and post-conditions in function definitions. These are particularly useful for ensuring proper bounds on the system, that help define correct execution. Consider a process that should send and receive a single message each round. We can define a pre-condition on a bounded parameter to ensure the process does not run indefinitely. Let us refactor the client process, to complete a number of rounds (determined by the server) before terminating.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    defmodule Client do
        @spec start_client() :: :ok
        def start_client do
            receive do
                {:bind, sender, round_limit} -> next_round(server, round_limit)
            end
        end

        @spec next_round(pid(), integer()) :: :ok
        def next_round(server, rounds) do
            send(server, {:im_alive})
            remaining_rounds = rounds - 1
            next_round(server, remaining_rounds)
        end
    end
\end{lstlisting}
We now introduce the \textbf{defv} macro from the LTLixir specification language. The \texttt{defv} macro is used to create \textbf{contracts}, using pre- and post-conditions. Pre-conditions check conditions regarding the values of function arguments on entry to the function and similarly, post-conditions can assert conditions on values within the scope of the function on exit. 
\\ \\
With this definition, we gain assurances that the implementation of the function behaves as we expect and that no other function interacts with it in a manner that violates our expected behaviour. We can create a contract for our client. We assert that, on each function entry, the number of rounds is positive, and on exit, the remaining number of rounds has decreased.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    defv next_round(server, rounds), pre: rounds >= 0, post: remaining_rounds < rounds do
        ...
    end
\end{lstlisting}
We can run Verlixir on the system to verify the pre-condition holds for every possible execution.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    An LTL, pre- or post-condition was violated. Generating trace.
    Violated: assertion violated (rounds>=0) (at depth 45).
    ... trace omitted ...
\end{lstlisting}
Verlixir reports an error, in particular, it notes the violation of an assertion. An assertion violation can be a violation of an LTL formula, and pre-condition or a post-condition. In this case, it outputs the assertion that was violated \texttt{rounds >= 0}, which we are aware is our pre-condition.
\subsection{Parameterized Systems}
Up to this point, we have declared various system properties such as \texttt{client\_n}, \texttt{alive\_client} and \texttt{rounds}. In reality, the value assigned to these properties could be determined by many factors and it may not be known to the developer at the time of writing the specification. To support this, Verlixir allows us to declare these properties as parameters, in particular, we want to declare concurrency parameters. We define concurrency parameters as variables that impact the behaviour of a distributed system (we will simply refer to them as parameters going forward). For example, in a consensus algorithm such as Paxos, we may have variables to determine the number of acceptors, proposers and size of a quorum. We can declare these variables as parameters in the specification in order to verify the system for multiple possible configurations. Typically, the values used in these auto-generated configurations will be small values, as large values may lead to a state space that becomes difficult to explore.
\\ \\
We use \texttt{@model} to mark variables as parameters. It takes a tuple of atoms referencing variables in the function scope. We can apply this definition to our existing server process.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Example of declaring concurrency parameters in specification.}]
    (*@\fbox{@model \{:client\_n, :number\_of\_rounds\}}@*)
    def start_server do
      client_n = 3
      number_of_rounds = 2
      predicate all_alive, alive_clients == client_n * number_of_rounds
      ...
    end
\end{lstlisting}
We can declare as many parameters as required. The values matched in the declaration of the variables will be ignored if we run Verlixir in parameterized mode. To run the verifier, we can use the $-p$ flag. To run the parameterized verification, we use the same command but with the $-p$ flag.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -p 3 basic_example.ex 
    Generating models.
    Generated 9 models.
\end{lstlisting}
We can introduce a bug into our program that will cause a violation of the specification, to show the output of the verifier under these circumstances. To introduce a bug, we are going to conditionally call \texttt{check\_clients/2} if \texttt{client\_n > 1} holds.
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
    (*@\fbox{@model \{:number\_of\_rounds\}}@*)
    def start_server do
        ...
        alive_clients = if number_of_rounds > 1 do
            check_clients(client_n * number_of_rounds, alive_clients)
        else
            0
        end
    end
\end{lstlisting}
This will now result in cases where the temporal property is violated, as $\texttt{alive\_clients} \equiv \texttt{client\_n} * \texttt{number\_of\_rounds}$ will not hold for all configurations. Note, that we have reduced the parameters down to just \texttt{\{number\_of\_rounds\}}. The system is theoretically capable of handling any number of parameters in its search. However, the computational cost of exploring the state space grows exponentially with the number of parameters.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
$ ./verlixir -p 3 basic_example.ex
Generating models.
Generated 3 models.
Violations found in models:
Model with params: {"number_of_rounds": '1'}
Assign these parameters to the system and re-run the verifier in verification mode to gather a trace.
\end{lstlisting}
The system found a violation for the assignment of 1 to \texttt{number\_of\_rounds}. To investigate, we could run the verifier on this configuration. It's also useful to note that Verlixir was executed with $-p 3$, this sets the range of values, from 0 to (p-1), for each parameter. 
\section{Summary}
We have now given a high-level overview of Verlixir, the verification toolchain capable of verifying Elixir programs written using the LTLixir specification language. We saw how to use Verlixir to simulate executions of the system; verify our system's adherence to a specification and parameterize concurrency parameters for exploration. This chapter also explained how to use LTLixir constructs, to reason about temporal properties, as well as how pre- and post-conditions can drive functional correctness. The next chapter will begin to explore the implementation of Verlixir.