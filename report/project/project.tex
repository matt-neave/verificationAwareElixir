\chapter{Verlixir} \label{chap:verlixir}
Verlixir is the main project contribution. The Verlixir toolchain supports the simulation and verification of a set of Elixir programs. This set is named LTLixir and is detailed in section \ref{sec:ltlixir}. This chapter aims to inform the reader of the constructs defined in LTLixir and how Verlixir can be used to reason about them. \ref{sec:ltlixir} introduces the LTLixir language and its constructs. \ref{sec:verifiable} provides an example of specifying a verifiable system and how Verlixir can be used to detect violations of a specification. The subsequent subsections provide further details of more interesting features of LTLixir, such as specifying temporal properties.
\section{LTLixir} \label{sec:ltlixir}
LTLixir is the multi-purpose specification language that compiles to BEAM byte-code and is supported for verification by Verlixir. Primarily, LTLixir is a subset of Elixir supporting both sequential and concurrent execution. This subset is expressive enough to implement well-known distributed algorithms such as basic paxos \cite{basic_paxos} and the alternating-bit protocol \cite{ab_protocol}. LTLixir extends Elixir with constructs for specifying temporal properties, specifically LTL properties (where LTLixir derives its name) as well as Floyd-Hoare style logic for specifying pre- and post-conditions. Specifications can be parameterized to identify violations of properties on specific configurations. 
\par
\section{Constructing a Verifiable Elixir Program} \label{sec:verifiable}
This section will walk through the basic construction of an LTLixir program, and show how we can verify the properties of the program using Verlixir. To begin, we define a server and client process. The server is responsible for creating clients and communicating with them. 
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Elixir definition for a server and client module}., label={fig:basic_server}]
    defmodule Server do
        def start_server do
            client = spawn(Client, :start_client, [])
        end
    end

    defmodule Client do
        def start_client do
            IO.puts "Client booted"
        end
    end
\end{lstlisting}
First, the server spawns a single client process, which writes to stdio. To ensure correctness when verifying properties of the system, we remove ambiguity by being particular in our naming of the functions \texttt{start\_server} and \texttt{start\_client}. Notice we could name both functions \texttt{start}, but this ambiguity can make it more difficult to digest a trail produced by Verlixir. With the system implemented, we must now declare an entry point to the system that Verlixir will use to begin verification. For this example, we can define \texttt{Server.server\_start} as the entry point using an attribute \texttt{\@vae\_init}.

\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Declaring an entry point to the system}., label={fig:vae_init}]
    (*@\fbox{@vae\_init true}@*)
    def start_server do
        client = spawn(Client, :start_client, [])
    end
\end{lstlisting}
Although we set the attribute \texttt{vae\_init} to \texttt{true}, note it is not required that other functions are set to \texttt{false}, this is already implied. With an entry point specified, we can begin using the available tools. By default, Verlixir reports the presence deadlocks and livelocks in the system. When specifying systems in LTLixir, we do not lose the capability to compile our program to BEAM byte-code, hence the system can still run as a regular Elixir program.
\par
More interestingly, we can now use Verlixir before the Erlang Run-Time System (ERTS) to verify the system adheres to our specification. With no additional properties defined, by running Verlixir we are ensuring that every possible execution results in a program termination. The presence of a deadlock or livelock will be reported. We can run the Verlixir executable by passing optional arguments as the path to the specification file. For example, we use the simulator flag $-s$ to run a single simulation of the system.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -s basic_example.ex 
    Client booted
\end{lstlisting}
Alternatively, we can use the $-v$ flag to run the verifier on the specification.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -v basic_example.ex 
    Model checking ran successfully. 0 error(s) found.
    The verifier terminated with no errors.
\end{lstlisting}
\subsection{Detecting a Deadlock} \label{sec:deadlock}
Now we have a basic understanding of what is required to write a specification, we will use Verlixir to detect a deadlock in the system. By default, the verifier will detect the presence of deadlocks and livelocks in the system. Deadlocks in Elixir programs can be introduced by circular waits, where two simultaneously executing processes are both waiting for a message from the other. To demonstrate this, we modify the existing client and server by introducing a circular wait. The server will now spawn the process, and expect to receive a message from the client, meanwhile, the client will expect to receive a message from the server. The resulting server and client processes are modeled below.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={A simple Elixir system with a deadlock}.]
    defmodule Server do
    (*@\fbox{@vae\_init true}@*)
    def start_server do
      client = spawn(Client, :start_client, [])
      receive do
        {:im_alive} -> IO.puts "Client is alive"
      end
    end
  end
  
  defmodule Client do
    def start_client do
      receive do
        {:binding} -> IO.puts "Client bound"
      end
    end
  end  
\end{lstlisting}
In this simple example, any execution of the system will result in a deadlock, the system can be considered deterministic in this regard. In many real-world systems with multiple processes, the presence of a deadlock can be difficult to detect due to multiple interleavings.
\par
We can now compare compare the output of running the new system from Verlixir.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -s basic_example.ex
    timeout
\end{lstlisting}
The simulator terminates, reporting a timeout. Already, running our specification using Verlixir provides more information than running the Elixir program. Let's now run the verifier.
\begin{lstlisting}[language=bash, xleftmargin=.2\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    The program likely reached a deadlock. Generating trace.
    [8] (proc_0) init:4 [receive do]
    [9] (proc_0) init:4 [receive do]
    [10] (proc_0) init:5 [{:im_alive} -> IO.puts "Client is alive"]
    [13] (proc_1) start_client:13 [{:binding} -> IO.puts "Client bound"]
    <<< END OF TRAIL, FINAL STATES: >>>
    [14] (proc_1) start_client:13 [{:binding} -> IO.puts "Client bound"]
    [15] (proc_0) init:5 [{:im_alive} -> IO.puts "Client is alive"]
\end{lstlisting}
Running the verifier produces more output. Let's break down step by step the output produced by Verlixir. 
\par
The first line of the output informs us that the verifier successfully terminated on the input, along with how many errors were found. If an error is found, Verlixir will use heuristics to profile the type of error, in this case, it has determined the program likely deadlocked. Once determining the error type, an error trail is produced to debug the source of the error. The underlying model derived from the LTLixir specification does not have a one-to-one mapping to the original Elixir code, hence again heuristics are applied to determine where in the Elixir program the trail is produced from. In this case, we can see reference to \texttt{init}, the entry point to the system (annotated previously by \texttt{@vae\_init}).
\par
Alongside the process, we can see a line number referring to a line number in the Elixir file, as well as the line of code the line refers to. With the exception of the system entry point, all other function names are labeled as in the original program, for example, $start\_client$.
\par
The remaining information on a trail line is less relevant to most users. The first number on a line is the step number (some of these may be omitted for simplicity). The \texttt{proc\_n} refers both to process numbers and function call stack depth.
\par
Alongside the error trace, Verlixir also reports a trace of all messages being sent and received through the system. These messages contain a lot of information, so may not always be easy to understand however if we take a look at the messages produced in this case, we see that no messages were ever sent. This could give a further indication as to why the deadlock has arrisen.
\par
Now we understand how to read a single line of the trail, we can read the trail in sequential order to learn the interleaving that resulted in the error. In this instance, we can see the server reaches line 5 where it waits for an \texttt{:im\_alive} message from the client and similarly, the client is waiting for a \texttt{:binding} message.
\subsection{Linear Temporal Logic}
We now introduce Linear-time Temporal Logic to our systems to allow us to write more interesting LTLixir specifications. Before doing so, we must detour to type specifications. Type specifications had been previously omitted from examples, but they are imperative for the correctness of LTLixir specifications. LTLixir supports some basic types such as \texttt{integer()}, \texttt{boolean()}, \texttt{atom()} and \texttt{pid()}. Internally, Verlixir treats process identifiers as integers, so \texttt{integer()} and \texttt{pid()} can be used interchangeably in specifications, for the following examples, we refer to process identifiers as integers. Message passing in specifications should be typed using atoms. To ensure this, any instance of a message should begin with an atom (which we will refer to as the message type). For example, \texttt{{:bind}} and \texttt{{:calculate, 10, 20}} are valid specification messages, \texttt{{false}} would be ignored by Verlixir. In type specifications, message types are typed as \texttt{atom()}. The atom \texttt{:ok} is reserved to identify non-returning functions. In Elixir, all functions return a value, so in this context, a 'non-returning function' is a function that's value is never matched. We briefly demonstrate the type specifications for two functions, the first is a non-returning function with no arguments and the second function takes two arguments and returns an integer.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Valid type specification examples}.]
    (*@\fbox{@spec start\_server() :: :ok}@*)
    def start_server do
        ...
    end

    (*@\fbox{@spec add(integer(), integer()) :: integer()}@*)
    def add a, b do
        ...
    end
\end{lstlisting}
Notice ($::$) marks the return type of the function. If these values are matched in the function body, they should not be matched to a different type.
\par
Let's now re-design the server and client processes so we can introduce temporal properties to reason about. The server will now spawn $n$ clients, bind the clients to itself and then await a response from all three clients. To achieve this, we introduce two variables \texttt{client\_n} and \texttt{alive\_clients} that will later be used in our temporal specification.
\begin{lstlisting}[language=Elixir, xleftmargin=.2\linewidth]
    def start_server do
        client_n = 3
        alive_clients = 0
        for _ <- 1..client_n do
            client = spawn(Client, :start_client, [])
            send(client, {:bind, self()})
        end
        alive_clients = check_clients(client_n, alive_clients)
    end
\end{lstlisting}
The implementation of the client process and the \texttt{check\_clients/2} function have been redacted, without understanding their implementation, we can still use our specification to verify the system acts as intended. We introduce our first LTL formula, which verifies that eventually, the number of alive clients is equal to $n$. To introduce an LTL formula, we can use the \texttt{@ltl} attribute. The attribute assigns an LTL formula, as a string, to function. The LTL grammar is defined as the following.
\begin{bnf*}
    \bnfprod{ltl}
      {\bnfpn{operand} \bnfor ( \bnfpn{ltl} ) \bnfor \bnfpn{ltl} \bnfpn{binop} \bnfpn{ltl} \bnfor \bnfpn{unop} \bnfpn{ltl}}\\
    \bnfprod{operand}
      {true \bnfor false \bnfor var \bnfor int \bnfor elixir\_expr}\\
    \bnfprod{unop}
      {\square \bnfor \lozenge \bnfor !}\\
    \bnfprod{binop}
      {U \bnfor W \bnfor V \bnfor \&\& \bnfor || \bnfor \rightarrow \bnfor \leftrightarrow }\\
\end{bnf*}
We want to verify that eventually, the number of alive clients equals the number the server created, we can write this using the formula $\lozenge (alive\_clients \equiv client\_n)$. Using the LTL attribute, we can update our server process.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Example LTL property}]
    @vae_init true
    @spec start_server() :: :ok
    (*@\fbox{@ltl "<>(alive\_clients == client\_n)"}@*)
    def start_server do
        ...
    end
\end{lstlisting}
Let us run Verlixir on the system.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 0 error(s) found.
    The verifier terminated with no errors.
\end{lstlisting}
Let's update the LTL formula, by replacing \texttt{clients\_n} with the number 1 ($\lozenge (alive\_clients \equiv 1)$). We run the verifier again.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    The program is livelocked, or an ltl property was violated. Generating trace.
\end{lstlisting}
The examples show how LTL properties can be specified and used to verify the system. Given the first LTL property was accepted, we know the formula holds. This is likely because the implementations of the client and \texttt{check\_clients/2} are correct, but we should also specify properties to check the validity of these functions instead of making this assumption.
\par
To help with readability, we can define inline predicates to use in LTL formulae. The predicates that can be defined are formed from a subset of the LTL grammar without the temporal modalities. Inline predicates can refer to variables in the scope of the function. For example, we can define a predicate \( p \) as $alive\_clients \equiv client\_n$. The predicates can take the name of any variable but should not reference variables that are already in scope. To help construct our example, let's also define a predicate \( q \) and set it to \( \neg p \). Using these predicates, we can strengthen our LTL formula to \( (q) \mathcal{U} (\square p) \). Informally, this formula states that there is a moment in time where $alive\_clients \equiv client\_n$, and from that moment onwards this property holds until termination. We can update our \texttt{start\_server} function to reflect this.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    (*@\fbox{@ltl "(q)U([]p)"}@*)
    def start_server do
      client_n = 3
      alive_clients = 0
      predicate p, alive_clients == client_n
      predicate q, !p
      ...
    end
\end{lstlisting}
\subsection{Pre- and Post-Conditions}
Verlixir has been designed to target system designs that are bounded in execution. As many real-world systems run long-lived processes, it is important that when writing LTLixir specifications there is a focus on termination conditions. For many distributed algorithms this could be completing a round of communication, reaching a consensus, awaiting a specific message to be received or reaching a stable system state. To aid this, LTLixir supports Floyd-Hoare style pre- and post-conditions in function definitions. These are particularly useful for ensuring proper bounds on the system that help define correct execution. Consider a process that should send and receive a single message each round. We can define a pre-condition on a bounded parameter to ensure the process does not run indefinitely. Let us refactor the client process to complete a number of rounds (determined by the server) before terminating. The client will receive a \texttt{:bind} message from the server, deciding how many rounds to complete and then will recurse until it has completed all the rounds.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    defmodule Client do
        @spec start_client() :: :ok
        def start_client do
            {server, rounds} = receive do
            {:bind, sender, round_limit} -> {sender, round_limit}
            end
            next_round(server, rounds)
        end

        @spec next_round(pid(), integer()) :: :ok
        def next_round(server, rounds) do
            send(server, {:im_alive})
            next_round(server, rounds - 1)
        end
    end
\end{lstlisting}
We can again run this with mix, and we can observe that the server terminates. Although our clients did not terminate, there was no indication of this. Processes in Elixir are isolated, so the termination of the server does not imply the termination of the clients (links can resolve this \cite{elixir_links}). It has become challenging to determine if our client is truely behaving as intended.
\begin{lstlisting}[language=bash, xleftmargin=.3\linewidth]
    $ mix run -e Server.start_server
    Generated app
    $
\end{lstlisting}
To help reason about this, we introduce the \texttt{defv} macro from the LTLixir specification language. The \texttt{defv} macro is used to define pre- and post-conditions on functions. Pre-conditions check conditions regarding the values of function arguments on entry to the function and similarly, post-conditions can assert conditions on values within the scope of the function on exit. For example, we could define a function \texttt{add\_positives/2} that takes two strictly positive numbers and sums them.
\begin{lstlisting}[language=Elixir, xleftmargin=.0\linewidth, caption={Example usage of pre- and post-conditions in LTLixir}]
    defv add_positives(a, b), pre: a > 0 and b > 0, post: result == a + b do
        ...
    end
\end{lstlisting}
With this definition, we gain assurances that the implementation of the function behaves as we expect and that no other function interacts with the function in a manner that violates our expected behavior. Let's take a similar approach with our client to help understand why the program does not terminate.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth]
    @spec next_round(pid(), integer()) :: :ok
    (*@\fbox{defv next\_round(server, rounds), pre: rounds >= 0 do}@*)
        ...
    end
\end{lstlisting}
We can run Verlixir on the system to verify the pre-condition holds for every possible execution.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -v basic_example.ex
    Model checking ran successfully. 1 error(s) found.
    An LTL, pre- or post-condition was violated. Generating trace.
    Violated: assertion violated (rounds>=0) (at depth 45).
\end{lstlisting}
Verlixir reports an error, in particular, it notes the violation of an assertion. An assertion violation can be a violation of an LTL formula, and pre-condition or a post-condition. In this case, it outputs the assertion that was violated \texttt{rounds >= 0}, which we are aware is our pre-condition. The depth refers to how many transitions were taken in the execution path before violation, to most users this information is not useful.
\subsection{Parameterized Systems}
Up to this point, we have declared various system properties such as \texttt{client\_n}, \texttt{alive\_client} and \texttt{rounds}. In reality, the value assigned to these properties could be determined by many factors and it may not be known to the developer at the time of writing the specification. To support this, LTLixir allows us to declare these properties as parameters, in particular, we want to declare concurrency parameters. We define concurrency parameters are variables that impact the behaviour of a distributed system (we will simply refer to them as parameters going forward). For example, in a consensus algorithm such as paxos, we may have variables to determine the number of acceptors, proposers and size of a quorum. We can declare these variables as parameters in the specification in order to verify the system for multiple possible configurations. Typically, the values used in these auto-generated configurations will be small values as large values may lead to a state-space that becomes difficult to explore.
\par
To mark a variable as a parameter, we again make use of attributes. The \texttt{@params} attribute takes a tuple of atoms referencing variables in the function scope. For example, \texttt{@params {:x, :y}} declares that $x$ and $y$ are configurable parameters that the verifier will explore. We can apply this definition to our existing server process.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Example of declaring concurrency parameters in specification.}]
    (*@\fbox{@params {:client\_n, :number\_of\_rounds}}@*)
    def start_server do
      client_n = 3
      number_of_rounds = 2
      predicate p, alive_clients == client_n * number_of_rounds
      ...
    end
\end{lstlisting}
We can declare as many parameters as required. The values matched in the declaration of the variables will be ignored if we run Verlixir in parameterized mode. To run the verifier, we can use the $-p$ flag. The verifier will calculate an acceptance confidence, \(\alpha \in [0, 1]\), where an $\alpha$ of 1 indicates all configurations were accepted by the verifier and an $\alpha$ of 0 indicates no configurations were accepted. In the case $\alpha < 1$, the verifier will output configurations that lead to violations in the system. Then, the system can run in verification mode to reproduce a trail that results in the violation. To run the parameterized verification, we use the same command but with the $-p$ flag.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
    $ ./verlixir -p basic_example.ex 
    Generating models.
    Generated 9 models.
    Acceptance confidence: 1.
\end{lstlisting}
We can introduce a bug into our program that will cause a violation of the specification to show the output of the verifier under these circumstances. To introduce a bug, we are going to conditionally call \texttt{check\_clients/2} if \texttt{client\_n > 1} holds.
\begin{lstlisting}[language=Elixir, xleftmargin=.1\linewidth]
@params {:number_of_rounds}
def start_server do
    ...
    alive_clients = if number_of_rounds > 1 do
        check_clients(client_n * number_of_rounds, alive_clients)
    else
        0
    end
end
\end{lstlisting}
This will now result in cases where the temporal property is violated, as $\texttt{alive\_clients} \equiv \texttt{client\_n} * \texttt{number\_of\_rounds}$ will not hold for all configurations. Note that we have reduced the parameters down to just \texttt{\{number\_of\_rounds\}}. The system is theoretically capable of handling any number of parameters in its search, however the computational cost of exploring the state-space grows exponentially with the number of parameters, hence in reality we should use our understanding of the system to determine which parameters to test at a time.
\begin{lstlisting}[language=bash, xleftmargin=.1\linewidth]
$ ./verlixir -p 3 basic_example.ex`
Generating models.
Generated 3 models.
Acceptance confidence: 0.6666666666666667.
Violations found in models:
Model with params: {"number_of_rounds": '1'}
Assign these parameters to the system and re-run the verifier in verification mode to gather a trace.
\end{lstlisting}
The system found a violation for the assignment of 1 to \texttt{number\_of\_rounds}. To investigate, we could run the verifier using the $-v$ flag on this configuration. We also now see our acceptance confidence has dropped below 1, due to an error produced by one of the configurations. It's also useful to note that Verlixir was executed with $-p 3$, this sets the range of values for the parameter, large numbers are not recommended and most users will find 3 sufficient. 
\section{Summary}
We have now given a high-level overview of Verlixir, the verification toolchain capable of verifying Elixir programs written using the LTLixir specification. We saw how to use Verlixir to simulate executions of the system, verify our system's adherence to a specification and parameterize concurrency parameters for exploration. This chapter also exposed how to use LTLixir constructs to reason about temporal properties as well as how pre- and post-conditions can drive functional correctness. The next chapter will begin to explore the implementation behind Verlixir.