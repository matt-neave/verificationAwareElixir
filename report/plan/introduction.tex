\chapter{Introduction}
With the rise of cloud-based clusters, developing robust distributed algorithms is becoming an increasingly difficult problem and the need for vigorous methodologies to verify the correctness of these algorithms has intensified. Distributed systems are interesting, as they provide performance and reliability benefits over centralised systems. They also provide scalability, modularity, and availability improvements \cite{cachin}.
\\ \\ 
Modern programming languages have been developed to support distributed algorithms that rely on message-passing as a means of communication. Common message-passing abstractions involve the use of channels (e.g. Go \cite{go}) or actors \cite{actor} (e.g. Erlang \cite{erlang}). At a high level, message-passing systems can be easier to reason about that a common alternative of shared memory. However, message-passing systems are often distributed across multiple nodes, which can introduce challenges in reasoning about the correctness of a system \cite{science_of_systems}.
\\ \\
Verification tools have been developed to support determining the correctness of systems. For example, first-order automated theorem provers such as Z3 \cite{z3} and formal specification languages like TLA+ \cite{tlaplus}. These tools allow systems to be modelled, and specifications to be defined that can then be used to prove properties over these systems. However, despite the power these tools provide, they often place a burden on developers to write and maintain models of systems alongside their actual implementation. This often leads to a paradigm shift away from system implementations that were designed in, for example, imperative programming languages such as C. Modern programming languages for example Dafny \cite{dafny} solve this issue by directly integrating Floyd-Hoare style logic verification alongside the implementation. This report aims to extend this notion to distributed, message-passing systems.
\\ \\
This report discusses the modelling of message-passing actor-based programs and the verification of their adherence to a specification, using Elixir as a target language to support the verification of real-world systems.
\section{Objectives}
This report introduces Verlixir, a verification-aware programming language for message-passing. Verlixir programs compile to byte-code to run on the BEAM VM, as well as guarantee system correctness under safety and liveness properties.
\\ \\
Much work has gone into verifying algorithms and programs such as various theorem provers and model checkers. While these tools were initially designed to allow developers to write specifications for how an algorithm should behave in bespoke specification language, more recently verification tools have been designed that can be directly applied to programs written in programming languages such as C \cite{c_to_promela}. A more recent advancement is support for verifying concurrent programs. However, much of this work has used global shared memory as an implementation for specifying process communication \cite{java_pathfinder}. This project sets out to accomplish the following objectives:
\begin{itemize}
    \item Integrate the verification of formal specifications into modern, message-based programming languages.
    \item Design a framework for simulating large-scale distributed systems.
    \item Check that the behaviour of a system is consistent across different configurations.
    \item Ensure verified systems can be run directly in production.
    \item Apply the aforementioned techniques and tooling to real-world systems implemented in Elixir.
\end{itemize}
The current research in the area of verifying modern programming languages presents many challenges for extending this notion to a message-passing system. State-of-the-art verification-aware languages such as Dafny avoid concurrent execution due to the challenges it can introduce to verification \cite{dafny_concurrency}. To verify a distributed system in this context, it is instead left to the user to model the system in a manner that it can be sequentially executed. Tools such as Gomela \cite{gomela} support verification of concurrent execution where communication is achieved across channels in Go. However, Go has a very different approach to the pure message-passing models we are interested in.
\section{Contributions}
To accomplish the objectives set out in this report, the following contributions have been made:
\begin{itemize}
    \item The primary contribution of this report is Verlixir. Verlixir is an analysis tool that parses Elixir programs and translates them into Promela \cite{promela} for model checking using the SPIN \cite{spin} model checker. Verlixir is capable of verifying multiple properties of highly concurrent Elixir programs and reporting back counterexamples in an Elixir-friendly format. Chapter \ref{chap:verlixir} provides an overview of what Verlixir is and how it can be used. We then provide a detailed explanation of the design and implementation of Verlixir in chapter \ref{chap:design}.
    \item The secondary contribution is LTLixir. LTLixir is a reduced subset of the standard Elixir language that has been extended to introduce linear temporal logic, propositional logic and contract design for specifying the behavior of a system alongside its implementation. Temporal properties specified in LTLixir can be verified using Verlixir. LTLixir is first introduced in section \ref{sec:ltlixir} and the design is discussed in section \ref{sec:specification_language}.
\end{itemize}