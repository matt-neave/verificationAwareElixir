\chapter{Introduction}
With the rise of cloud-based clusters, developing robust distributed algorithms is becoming an increasingly difficult problem and the need for vigorous methodologies to verify the correctness of these algorithms has intensified. Distributed systems are interesting, as they provide performance and reliability benefits over centralised systems. They also provide scalability, modularity, and availability improvements \cite{cachin}.
\\ \\ 
Modern programming languages have been developed to support distributed algorithms that rely on message passing as a means of communication. Common message passing abstractions involve the use of channels (e.g. Go \cite{go}) or actors \cite{actor} (e.g. Erlang \cite{erlang}). At a high level, message-passing systems can be easier to reason about than a common alternative, shared memory. However, message-passing systems are often distributed across multiple nodes, which can introduce challenges in reasoning about the correctness of a system \cite{science_of_systems}.
\\ \\
Verification tools have been developed to support determining the correctness of systems. For example, first-order automated theorem provers such as Z3 \cite{z3} and formal specification languages like TLA+ \cite{tlaplus}. These tools allow systems to be modelled, and specifications to be defined that can then be used to prove properties over these systems. However, despite the capabilities these tools provide, they often place a burden on developers to write and maintain models of systems alongside their actual implementation. This often leads to a paradigm shift away from system implementations that were designed in, for example, imperative programming languages such as C. Modern programming languages, for example Dafny \cite{dafny}, solve this issue by directly integrating Floyd-Hoare style logic verification alongside the implementation. This report aims to extend this notion to distributed, message-passing systems.
\\ \\
This report discusses the modelling of message passing, actor-based programs and the verification of their adherence to a specification, using Elixir as a target language to support the verification of real-world systems.
\section{Objectives}
Much work has gone into verifying algorithms and programs such as various theorem provers and model checkers. While these tools were initially designed to allow developers to write specifications for how an algorithm should behave in bespoke specification language, more recently verification tools have been designed that can be directly applied to programs written in programming languages such as C \cite{c_to_promela}. A more recent advancement is support for verifying concurrent programs. However, much of this work has used global shared memory as an implementation for specifying process communication \cite{java_pathfinder}. A common inter-process communication, alternative to shared memory, is message passing. We aim to extend the research in this area, to support the simulation and verification of message-passing systems, in particular, those which follow the actor model \cite{actor}. This project sets out to accomplish the following objectives:
\begin{itemize}
    \item Integrate the verification of formal specifications into modern, message-based programming languages.
    \item Check that the behaviour of a system is consistent across different configurations.
    \item Design a framework for simulating the behaviour of large-scale distributed systems.
    \item Ensure verified systems can be run directly in production.
    \item Apply the aforementioned techniques and tooling to real-world systems implemented in Elixir.
\end{itemize}
The current research in the area of verifying modern programming languages presents many challenges for extending this notion to a message-passing system. We define a verification-aware language, as one which combines implementation and verification capabilities into a single language.  State-of-the-art verification-aware languages such as Dafny avoid concurrent execution due to the challenges it can introduce to verification \cite{dafny_concurrency}. To verify a distributed system in this context, it is instead left to the user to model the system in a manner that it can be sequentially executed. Tools such as Gomela \cite{gomela}, support the verification of concurrent execution, where communication is achieved across channels in Go. However, they do not support formal specifications or the extensive verification of safety and liveness properties. Instead, they are limited to detecting deadlocks. The existing research means we must sacrifice either, the ability to verify concurrent execution or the ability to verify complex properties.
\section{Contributions}
This report introduces Verlixir, a verification-aware programming language for message passing. We believe Verlixir to be the first language to support the verification of safety and liveness properties of message-passing, actor-based systems. Verlixir programs compile to byte-code, so they can be run in production environments, such as on the Erlang Virtual Machine. They also guarantee system correctness under specified system properties.
\\ \\
Verlixir is capable of verifying multiple properties of highly concurrent programs and reporting back counterexamples. Chapter \ref{chap:verlixir} provides an overview of what Verlixir is and how it can be used. We then provide a detailed explanation of the design and implementation of Verlixir in chapter \ref{chap:design}.
\\ \\
A subsequent contribution of this project is LTLixir. LTLixir is a specification language, which supports the direct integration of linear temporal logic, propositional logic and contract design, with Elixir programs. Specifications can be simulated and verified using Verlixir. This allows for simple prototyping of complex, real-world distributed systems, in a controlled environment.