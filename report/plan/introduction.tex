\chapter{Introduction}
With the rise of cloud-based clusters, developing robust distributed algorithms is becoming an increasingly difficult problem and the need for vigorous methodologies to verify the correctness of these algorithms has intensified. Modern programming languages have been developed to support distributed algorithms that rely on message-passing as a means of communication between sequential nodes executing in parallel. Common message-passing abstractions involve the use of channels (e.g. Go \cite{go}) or actors \cite{actor} (e.g. Erlang \cite{erlang}). Message-passing abstractions are simpler to reason about than a common alternative in shared-memory concurrency, however, it becomes more difficult to verify a program implements a given specification.
\par
Verification tools have been developed to support determining the correctness of systems. For example, first-order automated theorem provers such as Z3 \cite{z3} and formal specification languages like TLA+ \cite{tlaplus}. These tools allow systems to be modelled, and specifications to be defined that can then be used to prove properties over these systems. However, despite the power these tools provide, they often place a burden on developers to write and maintain models of systems alongside their actual implementation. This often leads to a paradigm shift away from system implementations that were designed in, for example, imperative programming languages such as C. Modern programming languages such as Dafny \cite{dafny} solve this issue by directly integrating Floyd-Hoare style logic verification alongside the implementation.
\par
Elixir \cite{elixir} is a functional programming language built on top of Erlang that runs on the BEAM virtual machine \cite{beam}. It is commonly used for building distributed, fault-tolerant applications because it supports concurrency, communication and distribution. Elixir actors are uniquely identified with a process identifier (pid) and associated with an unbounded mailbox. Each mailbox supports communication between actors; one actor can send a message to another actor's mailbox, which is then enqueued and can be received in a First-In-First-Firable-Out (FIFFO) ordering. FIFFO is similar to First-In-First-Out (FIFO) where elements are dequeued in the order they are enqueued, however, Elixir supports receiving messages with pattern-matching such that messages are received in a FIFO order concerning a certain pattern.
\par
This report discusses the automatic modelling of actor-based programs and the verification of their adherence to a specification, using Elixir as a target language to support the verification of real-world systems.
\section{Objectives}
Much work has gone into verifying algorithms and programs such as various theorem provers and model checkers. While these tools were initially designed to allow developers to write specifications for how an algorithm should behave in bespoke specification language, more recently verification tools have been designed that can be directly applied to programs written in programming languages such as C. An even more recent advancement is support for verifying concurrent programs, however much of this work has used global shared memory as an implementation for specifying process communication. This project sets out to accomplish the following objectives:
\begin{itemize}
    \item Design novel modelling techniques for actor-based systems.
    \item Determine how specifications can be succinctly specified for actor-based systems.
    \item Design a toolkit for automation of the model checking and verification processes.
    \item Apply the aforementioned techniques and tooling to real-world systems using Elixir as an implementation of the actor model.
\end{itemize}
