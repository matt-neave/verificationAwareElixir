\chapter{Conclusion}
In this paper, we aimed to provide modelling and verification techniques for message-passing systems. To evaluate these techniques, we targetted Elixir, the actor-based, concurrent programming language. As part of our research, we introduced Verlixir, a framework to support a verification-aware Elixir.
\par
Verlixir supports verification of in-line specifications, written using predicate and temporal logic. We demonstrated that Verlixir is capable of verifying a multitude of safety and liveness properties specified for real-world distributed algorithms. 
\section{Future Work}
Throughout the course of research, we have identified several areas for future work. We have indicated some of these areas previously, but we will discuss them in more detail here. An obvious extension would involve supporting a larger Elixir feature set, but we will not discuss this here.
\par
A large inspiration for this project was the verification-aware language, Dafny. The Dafny language sets out to achieve similar claims to Verlixir, but takes a different approach. Dafny fundamentally relies on theorem proving for verification, whereas Verlixir uses model checking. In particular, Dafny transpiles to Boogie, a verification-aware intermediate language. Boogie currently then uses Z3 for theorem proving. Theorem proving provides formal proofs of correctness, that gives stronger claims than the pre- and post-condition checks we assert in model checking. We believe an ideal solution to verify message-passing systems could involve a combination of both theorem proving and model checking. We could extend Verlixir to support theorem proving within Elixir processes, and then continue to use model checking for verifying inter-process communication. This would provide a stronger guarantee of correctness for the system as a whole.
\par
Throughout table \ref{table:vs}, we explored the differences between Verlixir and other verification-aware languages. A key insight from this table is the lack of capability for injecting faults into models. Many distributed algorithms have been designed with an approach such that given there are no more than, some $f$ faults, the system will still follow the specification. In order to truly scrutinise these algorithms, we need the capability to inject faults into the system. A simple extension to Verlixir could involve injecting random terminating faults into processes, and then observing the system's fault tolerance under these conditions.
\par
A second insight gathered from \ref{table:vs} is the lack of support for verifying computation tree logic (CTL) in modern programming languages. CTL is a temporal logic that allows us to reason about paths in a system. A simple example of where CTL could be useful is in verifying the Paxos algorithm. To ensure fairness between all proposers, we could specify and verify a CTL property that states: there exists a path where each proposers proposal is accepted. We believe that extending Verlixir to support CTL would provide a more comprehensive verification framework for message-passing systems.
\section{Ethical Considerations}
Throughout the report we make reference to critical distributed-systems used in the contexts of air traffic control and healthcare. While the tools and research discussed are designed to improve the reliability of these systems, relying on them in isolation is not sufficient. Testing distributed systems is hard, and it is important rigorous testing is performed by multiple parties using multiple techniques.
\par
That said, we believe Verlixir provides an advancement in the verification of distributed systems.
\section{Final Remarks}
The goal for this project was to design a tool that could verify real-world distributed algorithms which are used in research and industry. Throughout researching Verlixir, many notional examples were used to demonstrate the capabilities of the tool. Through the evaluation, we have shown these capabilities extend to real, well-known algorithms such as Paxos and Raft. In achieving this, we believe Verlixir has the potential to be a valuable tool for verifying distributed systems.
\par
Historically, model checking has required hand-translation of code into a model. Verlixir lowers the barrier to entry for verifying systems. If a programmer can write their implementation using the provided LTLixir set, the system verification comes for free. We believe moving towards a world where verification-aware languages become the standard will greatly improve the reliability of code. Instead of programmers thinking about how to implement a system, instead they can focus on what the system should do. A shift in mindset away from implementation specifics towards reasoning about the safety and liveness of a system means that we can describe our systems is a more unified way.
\par
With the recent rise in artificially intelligent copilots \cite{attention_is, copilot_asset,safety_ai}, the future of programming could move towards a more declarative style. We programmers could simply be burdened to write the system specification, and a large-language model could generate the implementation.