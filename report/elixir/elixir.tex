\chapter{Promela and Elixir} \label{chap:promela_elixir}
In chapter \ref{chap:verlixir}, we will introduce the Verlixir tool. Verlixir involves the parsing of Elixir programs, which are translated into a formal model. This model is written in Process Meta Language (Promela). This chapter will introduce both Promela and Elixir. We will go through the core concepts and syntactic elements that Verlixir relies upon to provide a verification-aware Elixir. 
\section{Promela} \label{sec:promela}
Promela is the verification modelling language used by the Spin model checker, to specify concurrent processes modelling distributed systems \cite{spin}. This section will discuss some of the core features that allow systems to be modelled and verified with Spin. This section aims to give an overview of the syntax and control of Promela, so any specifications in later sections or the code artifact can be read.
\subsection{Types and Variables}
Promela is statically typed. Variables can be declared once within the current scope and then re-assigned throughout. Variables can be declared locally within the context of a process, or in the global scope, where memory is shared. The types available in Promela, and assignment to variables of these types is similar to many imperative programming languages. Promela supports the types bit, bool, byte, pid, short, int and unsigned. Variable declaration and assignment then naturally follows.
\[
\begin{aligned}
\text{int a} = 2;
\end{aligned}
\]
Promela supports \textbf{arrays}. Arrays are typed and declared with a fixed size. Array bounds are constant, so the size cannot change. Only single dimensional arrays are supported. The syntax for declaring an array is as follows.
\[
\begin{aligned}
\text{int array[10];}
\end{aligned}
\]
We can also extend the basic types using \texttt{typedef}. This allows us to define records of multiple nested types. We use these records to build a Promela library, to support model checking Elixir programs, using \textbf{embedded C} code and Promela \textbf{inlines}. Embedded C code cannot be model checked, but Promela inlines can be. These features allow us to extend Promela, and avoid some of the limitations discussed in section \ref{sec:promela_limitations} 
\subsection{Control Flow}
Promela supports some basic control flow concepts. Firstly, the \texttt{skip} expression can be used with no effect when executed, other than possibly changing the control of an executing process. The selection construct \texttt{if} can be used to evaluate expressions and execute sequences based on the evaluation of these expressions. The syntax of an if statement is unique in comparison to a typical programming language.
\begin{lstlisting}[language=promela, xleftmargin=.3\linewidth]
if
    :: 1 + 1 < 3 ->
        printf("Condition 1...");
    :: else -> 
        printf("No conditions matched");
fi
\end{lstlisting}
In Promela, $else$ is a reserved keyword that can be used in any condition. An $else$ condition will negate all the previous conditions.
Repetition can be achieved either through the \texttt{do} construct, through the use of labels or with \texttt{for} loops. We will primarily focus on \texttt{do}, as it is the most suitable for our modelling needs.
\begin{lstlisting}[language=promela, xleftmargin=.3\linewidth]
do
    :: a < 10 -> 
        a = a + 1;
    :: a < 10 ->
        a = a + 2;
    :: else -> 
        break;
od
\end{lstlisting}
Unlike \texttt{if}, which selects sequentially, \texttt{do} will non-deterministically select a true branch to execute. This means for the above example, for a given execution, we cannot say how many iterations are performed. The \texttt{break} keyword is reserved for explicitly breaking out of the loop.
\\ \\
An important concept in contract specification is the \textbf{assert} keyword. An assertion is a logical statement that is expected to be true at a given point in the program. If an assertion is false, a violation is reported.
\subsection{Processes}
An imperative component of understanding the power of the Spin model checker is understanding how processes can run concurrently. Every Promela model requires an initial process that is spawned in the initial system state and determines the control of the program from the initial state. The \texttt{init} keyword is reserved for this purpose. Other processes can be defined using the \texttt{proctype} keyword and then spawned with \texttt{run}. Each process is assigned a process id (pid) which can be accessed within the context of a process using globally defined read-only variable \texttt{\_pid}. We can now define two processes, a process active in the initial state and a second process that is spawned.
\begin{lstlisting}[language=promela, xleftmargin=.3\linewidth, caption={Defining and spawning processes in Promela}., label={fig:promela_processes}]
    proctype SomeProcess(int a) {
        printf("Do something with %d\n", a);
    }
    
    init {
        int p1;
        p1 = run SomeProcess(10);

        printf("Init process spawned at %d\n", _pid);
        printf("Process 1 spawned at %d\n", p1);
    }
\end{lstlisting}
Processes run independently of one another, so a parent process terminating will not necessarily result in the termination of a child. Spin sets a limit of 255 concurrently executing processes. Multiple processes can be spawned in a single transition by using the \textbf{atomic} construct, which will ensure that no spawning process is scheduled, until all atomic processes have been scheduled. Similarly to atomicity, \texttt{d\_step} can be used to enforce multiple statements are treated as a single indivisible step. Unlike \texttt{atomic}, \texttt{d\_step} cannot block or jump.
\\ \\
Instead of \texttt{init}, we could have used an \textbf{active proctype}. Every \textbf{active proctype} is spawned in the initial state, allowing for more than one process to initially run.
\subsection{Channels}
The final concept to briefly discuss, is the asynchronous communication primitive, channels. Promela allows channels to be specified using the predefined data type \texttt{chan}. To correctly specify communication, we often need to allow messages of multiple types to be written to channels. For this reason, Promela introduces \texttt{mtype} that allows for the introduction of symbolic names for constant values.
\[
\text{mtype = \{ BROADCAST \};}
\]
Now, we can define a channel that expects a message to contain multiple fields and is bound to contain a maximum of 10 messages at any time.
\[
\text{chan global\_broadcast = [10] of \{ mtype, int \};}
\]
We now input messages to the channel using the (!) operator.
\[
\text{global\_broadcast ! BROADCAST, 1;}
\]
Similarly, we read messages from the channel in a first-in, first-out (FIFO) order.
\[
\begin{aligned}
& \text{int x;} \\
& \text{global\_broadcast ? BROADCAST, x;}
\end{aligned}
\]
Where the variable $x$ stores the resulting \texttt{int}, assuming the first message in the channel is of type \texttt{BROADCAST}. Sending and receiving from channels also supports an alternative flavour. The (!!) and (??) operators are used for sorted insertion and random selection. \textbf{Sorted insertion} (!!), will insert a message into the channel in a sorted order, based on the first field of the message. \textbf{Random receive} (??), is not random. As opposed to FIFO, it will select the first message in the channel that matches a given pattern. We call this first-in, first-fireable-out (FIFFO).
\subsection{Promela Example}
We will now provide a simple example of a Promela specification. The specification models Dijkstra's Semaphore. It consists of two labelled processes, and an initial process to coordinate the system. A shared channel is used, with a buffer size of 0, which means the channel is blocking (rendezvous). Listing \ref{lst:dijkstra_semaphore} shows the Promela specification.
\begin{lstlisting}[language=promela, xleftmargin=.3\linewidth, caption={Dijkstra's Semaphore in Promela}, label={lst:dijkstra_semaphore}]
#define p	0
#define v	1

chan sema = [0] of { bit };

proctype dijkstra() {	
    byte count = 1;

    do
    :: (count == 1) ->
        sema!p; count = 0
    :: (count == 0) ->
        sema?v; count = 1
    od	
}

proctype user() {	
    do
    :: sema?p;
        /* critical section */
    sema!v;
        /* non-critical section */
    od
}

init {	
    run dijkstra();
    run user();
    run user();
    run user()
}
\end{lstlisting}
The semaphore guarantees that only one of the user processes can enter its critical section at a time.
\subsection{Limitations} \label{sec:promela_limitations}
Promela is a powerful language for modelling concurrent systems, but it has limitations for capturing the full complexity of a real-world system. In general, hand-translations of a system into Promela can avoid some of these limitations with careful design. However, we are approaching this limits from an Elixir perspective, where features of Elixir may not be easily translated into Promela.
\begin{itemize}
    \item \textbf{Compute}: Promela is not designed to model complex computations. It does not support floating-point arithmetic, so we are limited to working with integers.
    \item \textbf{Memory}: Promela does not support dynamic memory allocation. This means we cannot model systems that require dynamic memory allocation, for example, linked lists.
    \item \textbf{Functions}: Promela does not support functions. It has no notion of a function call or return. By extension, Promela does not support recursion.
    \item \textbf{Randomness}: a Spin execution may not be deterministic, but it cannot model true randomness.
    \item \textbf{Probability}: there is no mechanism for modelling probabilistic behaviour, all correctness claims are checked unconditionally.
    \item \textbf{Time}: there is no notion of a system block, or related time properties in Promela. This means we cannot model sleeping threads.
\end{itemize}
In chapter \ref{chap:design}, we will discuss how we can overcome some of these limitations. In particular, how we overcome the lack of functions and dynamic memory, by introducing a Promela library, which handles these features.
\subsection{Summary}
This basic introduction to the syntax of the Promela modelling language, aims to make the reader familiar with the syntax involved in writing Promela specifications. It is not an exhaustive guide but should form a basis for understanding specifications present in a later section or the code artifact.

\section{Elixir}
Elixir \cite{elixir} is a functional programming language built on top of Erlang \cite{erlang} that runs on the BEAM virtual machine \cite{beam}. It is commonly used for building distributed, fault-tolerant applications because it supports concurrency, communication and distribution. Elixir actors are uniquely identified with a process identifier (pid) and associated with an unbounded mailbox. Each mailbox supports communication between actors; one actor can send a message to another actor's mailbox, which is then enqueued and can be received in a First-In-First-Firable-Out (FIFFO) ordering. FIFFO is similar to First-In-First-Out (FIFO) where elements are dequeued in the order they are enqueued. However, Elixir supports receiving messages with pattern-matching such that messages are received in a FIFO order concerning a certain pattern.
\\ \\
BEAM is a virtual machine that executes user programs in the Erlang Runtime System (ERTS). BEAM is a register machine where all instructions operate on named registers containing Erlang terms such as integers or tuples.
\\ \\
We have recently seen companies adopting Elixir in industry, in particular in domains such as telecoms and instant messaging. The Phoenix Framework \cite{phoenix} is a framework for building interactive web applications natively in Elixir, that can take advantage of Elixir's multi-processing and fault tolerance to build scalable web applications. The audio and video communication application Discord \cite{discord} uses Elixir to manage its 11 million concurrent users and the Financial Times \cite{ft} have begun migrating from Java to Elixir to enjoy the much smaller memory usage by comparison.
\\ \\
Elixir supports multi-processing in two key ways: nodes and processes. Each node is an instance of BEAM (a single operating system process), when an Elixir program is executed, a new instance of BEAM is instantiated for it to run on. In contrast, an Elixir process is not an operating system process. An Elixir process is lightweight in terms of memory and CPU usage (even in comparison to threads that many other programming languages favour). Elixir processes can run concurrently with one another and are completely isolated from one another. Elixir processes communicate via message passing.
\begin{lstlisting}[language=Elixir, xleftmargin=.2\linewidth, caption={An example of spawn/1 and spawn/4 in Elixir for spawning a new lightweight process and a new Elixir node}]
    # Spawn a new process
    spawn(fn -> 1 + 2 end)

    # Create a new BEAM instance
    Node.spawn(:"node1@localhost", MyModule, :start, [])
\end{lstlisting}

In Elixir, a receive statement is used to read messages in the mailbox. The receive block looks through the mailbox for a message that matches a given pattern. If no messages match the pattern, the process will block until one does.
\begin{lstlisting}[language=Elixir, xleftmargin=.4\linewidth, caption={An example of spawn/1 and spawn/4 in Elixir for spawning a new lightweight process and a new Elixir node}]
    # Example send in Elixir
    send self(), {:hello, "world"}

    # Example receive block in Elixir
    receive do
        {:hello, msg} -> IO.puts msg
    end
\end{lstlisting}
\subsection{Verifiable Feature Set} \label{sec:verifiable_feature_set}
In chapter \ref{chap:verlixir}, we will introduce Verlixir. Verlixir is designed to support a reduced set of core Elixir constructs. We will introduce these constructs here to give an overview of what the tool is capable of supporting.
\\ \\
Everything in Elixir is an expression. This means that every piece of code returns a value. For example, an $if$ statement will return a value dependent on the branch taken. This means that any expression can be matched on, using Elixir's match (=) operator. We can use pattern matching to match on the shape of an expression's evaluation. The set of expressions supported by Verlixir are:
\begin{itemize}
    \item \textbf{Values}: any value of a basic, primitive type such as integers and booleans. Elixir also has a concept of $atoms$. An atom is identified by a preceding colon (:), and is followed by letters, digits, `\_', `@' or a string.
    \item \textbf{Variables}: Elixir is dynamically, strongly typed. Variables are bound to using the match operator. Variable names start with lowercase letters. The `\_' character can be used to match an expression of any shape.
    \item \textbf{Data structures}: structures such as lists and tuples are treated as values. Lists are dynamic, whereas tuples are fixed in size. Lists are written as [1, 2, 3] and tuples are written as \{1, 2, 3\}. We can match on the shape of these data structures using pattern matching.
    \item \textbf{Pattern matching}: pattern matching can be used to match on the shape of an expression. In the context of a conditional guard, values can be used to evaluate the shape of an expression, where as variables can be used to bind to the value of an expression. For example, the pattern ${:ok, value}$, can be used to assign to the variable $value$ if the expression is a tuple shape, with an atom $ok$ as the first element.
    \item \textbf{Functions}: functions are defined using the $def$ keyword. Functions can group multiple sequentially executable expressions. Any function can be called or spawned as a new process or node.
    \item \textbf{Modules}: functions are grouped into modules.
    \item \textbf{Message passing}: Elixir's actor model supports message passing. Messages are sent and received between actors and their mailboxes.
    \item \textbf{Control flow structures}: Elixir supports many control flow expressions. For example, $if$, $case$, $unless$ and $for$. All of these introduce a new scope. They are expressions and can be matched on.
\end{itemize}
The feature set supported has been shown expressive enough to support real-world systems in chapter \ref{chap:eval}. We omit some features of Elixir. For example, data structures like sets and maps are not supported. We determined lists sufficient for our purposes. The supported feature set can be easily extended to support other data structures.
\subsection{Type Specifications}
Type specifications are imperative for the correctness of Verlixir specifications. Verlixir supports some basic types such as \texttt{integer()}, \texttt{boolean()}, \texttt{atom()} and \texttt{pid()}. Type specifications are not enforced by the Elixir compiler, but tools such as Dialyzer and Verlixir rely them.
\\ \\
In type specifications, message types are typed as \texttt{atom()}. The atom \texttt{:ok} is reserved to identify a \textbf{non-returning function}. In Elixir, all functions return a value, so in this context, a `non-returning function', is a function that's value is never matched. We briefly demonstrate the type specifications for two functions, the first, is a non-returning function with no arguments and the second function, takes two arguments and returns an integer.
\begin{lstlisting}[language=Elixir, xleftmargin=.3\linewidth, caption={Valid type specification examples}.]
    (*@\fbox{@spec bind\_server() :: :ok}@*)
    def bind_server do
        ...
    end

    (*@\fbox{@spec add(integer(), integer()) :: integer()}@*)
    def add a, b do
        ...
    end
\end{lstlisting}
Notice ($::$) marks the return type of the function. If these values are matched in the function body, they should not be matched to a different type.
\\ \\
Within a correct Verlixir specification, any message should also be typed. To ensure this, any instance of a message should begin with an atom which we will refer to as the \textbf{message type}. For example, \texttt{\{:bind\}} and \texttt{\{:calculate, 10, 20\}} are valid specification messages. The message, \texttt{\{false, 15\}}, would be ignored by Verlixir, as it does not begin with an atom. 
\subsection{Summary}
In this chapter, we learned about Elixir, the programming language built on top of Erlang and we explored some basic approaches to designing concurrent systems with it. The next section will explore how these core tools can be used in tandem, to provide developers guarantees over large-scale, distributed Elixir-based systems.